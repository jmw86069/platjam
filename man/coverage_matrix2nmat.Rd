% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/platjam-import.R
\name{coverage_matrix2nmat}
\alias{coverage_matrix2nmat}
\title{Import genome coverage matrix files}
\usage{
coverage_matrix2nmat(
  x = NULL,
  filename = NULL,
  signal_name = NULL,
  target_name = "target",
  background = 0,
  smooth = FALSE,
  target_is_single_point = FALSE,
  signal_is_categorical = FALSE,
  mat_grep = "[-0-9]+:[-0-9]+",
  upstream_grep = "^[-]",
  downstream_grep = "^[^-]",
  target_grep = "^0$",
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x}{\code{data.frame} or compatible object containing
genome coverage data, or a character file path. When
\code{x} is not supplied, \code{filename} is used to import
data. When \code{x} is a filename, it is used to populate
\code{filename}, then data is imported into \code{x}.}

\item{filename}{character path to a genome coverage file.
When \code{x} is supplied, this argument is ignored. When
\code{filename} is used, only the first file is imported.}

\item{signal_name}{The name of signal regions. It is only used
for printing the object. When \code{signal_name} is \code{NULL}, the
\code{signal_name} is derived from \code{names(filename)} if
available, then \code{basename(filename)}, or \code{"signal"} then
only \code{x} is supplied.}

\item{target_name}{The name of the target names. It is only used
for printing the object.}

\item{background}{numeric value containing the background
value in the matrix.}

\item{smooth}{logical whether to apply smoothing on rows.}

\item{target_is_single_point, signal_is_categorical}{logical
indicating whether the target region is a single point,
and whether signal matrix is categorical, respectively.}

\item{mat_grep}{character regular expression pattern used
to identify colnames which contain coverage data. The
default pattern expects the format \code{"-200:-100"}.}

\item{upstream_grep}{character regular expression pattern
used to identify upstream colnames from values that
match \code{mat_grep}. The default assumes any region
beginning \code{"-"} is negative and upstream the central
target region.}

\item{downstream_grep}{character regular expression pattern
used to identify upstream colnames from values that
match \code{mat_grep}. The default assumes all colnames which
are not upstream are therefore downstream.}

\item{target_grep}{character regular expression pattern
used to identify a colname referring to the \code{target},
which by default can only be \code{"0"}. Otherwise, no target
region is defined.}

\item{verbose}{logical indicating whether to print verbose output.}

\item{...}{additional arguments are ignored.}
}
\value{
\code{normalizedMatrix} numeric matrix, where additiona
metadata is stored in the object attributes. See
\code{EnrichedHeatmap::as.normalizedMatrix()} for more
details about the metadata. The \code{rownames} are defined
by the first colname which does not match
\code{mat_grep}, which by default is \code{"Gene ID"},
otherwise rownames are \code{NULL}.
}
\description{
Import genome coverage matrix files
}
\details{
This function imports genome coverage data matrix
and returns an object of class
\code{normalizedMatrix} compatible for use by the
package \code{"EnrichedHeatmap"}.

There is a conversion function \code{EnrichedHeatmap::as.normalizedMatrix()},
however this function does not call that function, in
favor of defining the attributes directly. In future, this
function may change to call that function.
}
\examples{
## There is a small example file to use for testing
cov_file <- system.file("data", "tss_coverage.matrix", package="platjam");
cov_file <- system.file("data", "h3k4me1_coverage.matrix", package="platjam");
if (length(cov_file) > 0) {
   nmat <- coverage_matrix2nmat(cov_file);
   jamba::printDebug("signal_name: ",
      attr(nmat, "signal_name"));

if (suppressPackageStartupMessages(require(EnrichedHeatmap))) {
   color <- "red3";
   signal_name <- attr(nmat, "signal_name");
   k <- 6;
   set.seed(123);
   partition <- kmeans(log10(1+nmat), centers=k)$cluster;
   EH <- EnrichedHeatmap(log10(1+nmat),
      split=partition,
      pos_line=FALSE,
      use_raster=TRUE,
      col=jamba::getColorRamp(color, n=10),
      top_annotation=HeatmapAnnotation(
         lines=anno_enriched(gp=grid::gpar(col=colorjam::rainbowJam(k)))
      ),
      axis_name_gp=grid::gpar(fontsize=8),
      name=signal_name,
      column_title=signal_name
   );
   PHM <- Heatmap(partition,
      use_raster=TRUE,
      col=structure(colorjam::rainbowJam(k),
         names=as.character(seq_len(k))),
      name="partition",
      show_row_names=FALSE,
      width=grid::unit(3, "mm"));
   draw(PHM + EH, main_heatmap=2);
}
}

}
\seealso{
Other jam coverage heatmap functions: 
\code{\link{get_nmat_ceiling}()},
\code{\link{nmathm_row_order}()},
\code{\link{nmatlist2heatmaps}()},
\code{\link{zoom_nmatlist}()},
\code{\link{zoom_nmat}()}

Other jam import functions: 
\code{\link{deepTools_matrix2nmat}()},
\code{\link{frequency_matrix2nmat}()},
\code{\link{import_lipotype_csv}()},
\code{\link{import_nanostring_csv}()},
\code{\link{import_nanostring_rcc}()},
\code{\link{import_proteomics_PD}()},
\code{\link{import_salmon_quant}()}
}
\concept{jam coverage heatmap functions}
\concept{jam import functions}
