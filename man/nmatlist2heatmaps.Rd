% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/platjam-import.R
\name{nmatlist2heatmaps}
\alias{nmatlist2heatmaps}
\title{Make multiple coverage heatmaps}
\usage{
nmatlist2heatmaps(nmatlist, k_clusters = 0, k_subset = NULL,
  k_colors = NULL, k_width = unit(3, "mm"), k_method = c("euclidean",
  "pearson", "correlation"), partition = NULL, rows = NULL,
  row_order = NULL, nmat_colors = NULL, main_heatmap = 1,
  anno_df = NULL, byCols = NULL, anno_row_marks = NULL,
  anno_row_labels = NULL, hm_nrow = 1, transform = jamba::log2signed,
  lens = -2, seed = 123, use_raster = TRUE, do_plot = TRUE,
  return_type = c("heatmaplist", "grid"), show_error = FALSE,
  verbose = FALSE, ...)
}
\arguments{
\item{nmatlist}{\code{list} containing \code{normalizedMatrix} objects,
usually the output from \code{coverage_matrix2nmat()}.}

\item{k_clusters}{integer number of k-means clusters to
use to partition each heatmap. Use \code{0} or \code{NULL} for
no clustering.}

\item{k_subset}{integer vector of k-means clusters to
retain. Often one cluster contains mostly empty
values, and can be removed using this mechanism.}

\item{k_colors}{vector of R colors, or \code{NULL} to use
the output of \code{colorjam::rainbowJam(k_clusters)}.}

\item{k_width}{unit width of the k-means cluster color
bar, used with \code{k_clusters}.}

\item{partition}{vector used to split rows of each
matrix in \code{nmatlist}, named by rownames. This
value is ignored when \code{k_clusters} is supplied.}

\item{rows}{vector of \code{rownames} or integer vector with
index of rows to keep from each matrix in \code{nmatlist}.}

\item{row_order}{integer vector used to order rows.
When \code{TRUE} or \code{NULL} it uses
the default for \code{EnrichedHeatmap::EnrichedHeatmap()}
which is the \code{EnrichedHeatmap::enriched_score()}
for the matrix \code{main_heatmap}. When \code{FALSE} the
rows are ordered by the order they appear in \code{rows},
which is either the order they appear in \code{nmatlist}
or the order after sorting \code{anno_df}. When
\code{TRUE} the default}

\item{nmat_colors}{named character vector of R colors,
to colorize each heatmap. When \code{NULL} then
\code{colorjam::rainbowJam()} is used to create colors
for each heatmap panel.}

\item{main_heatmap}{integer index referring to the
entry in \code{nmatlist} to use for clustering and row
ordering.}

\item{anno_df}{\code{data.frame} or object that can be coerced,
used to annotate rows of each matrix. It must have
\code{rownames(anno_df)} that match \code{rownames(nmatlist)}.
When supplied, data can be sorted using \code{byCols}.
Note that only the \code{rownames(anno_df)}
present in both \code{nmatlist} and \code{anno_df} are
used to display the heatmaps. These rows
may also be subsetted using argument \code{rows}.}

\item{byCols}{character vector of  values in
\code{colnames(anno_df)} used to sort the data.frame
via \code{jamba::mixedSortDF()}. Any colname with
prefix \code{-} will be reverse-sorted.}

\item{anno_row_marks}{character vector of \code{rownames}
which will be labeled beside the heatmaps, using
the \code{ComplexHeatmap::anno_mark()} method. It currently
requires \code{anno_df} be defined, since it uses the
first column in \code{anno_df} as a one-column heatmap,
to anchor the labels.}

\item{anno_row_labels}{character vector of optional
character labels to use instead of \code{rownames}.
If \code{NULL} then \code{anno_row_marks} are used. Or
\code{anno_row_labels} may contain a character vector
of \code{colnames(anno_df)} which will create labels
by concatenating each column value separated by
space \code{" "}.}

\item{hm_nrow}{integer number of rows used to display
the heatmap panels.}

\item{transform}{\code{function} used to transform numeric
values in each entry in \code{nmatlist}. When supplied
as a \code{list}, the values are recycled to \code{length(nmatlist)}
and applied to each matrix in order.}

\item{lens}{numeric value used to scale each heatmap
color ramp, using \code{getColorRamp()}.}

\item{seed}{numeric value used with \code{set.seed()} to
set the random seed. Set to \code{NULL} to avoid running
\code{set.seed()}.}

\item{use_raster}{logical indicating whether to create heatmaps
using raster resizing, almost always recommended \code{TRUE}.}

\item{do_plot}{logical indicating whether to draw the heatmaps,
where \code{FALSE} will return the data used to create heatmaps
without actually drawing the heatmaps.}

\item{return_type}{character string indicating the type of
data to return: \code{"heatmaplist"} returns the list of heatmaps,
which can separately be arranged together using
\code{ComplexHeatmap::draw()} or \code{grid::grid.draw()}.}

\item{show_error}{logical indicating whether to add error
bars to the profile plot at the top of each heatmap.
These error bars are calculated by
\code{EnrichedHeatmap::anno_enriched()} using
\code{matrixStats::colSds(x)/nrow(x)}.}

\item{verbose}{logical indicating whether to print verbose output.}

\item{...}{additional arguments are passed to
\code{EnrichedHeatmap::EnrichedHeatmap()} to allow greater
customization of details. Note that many \code{...} arguments
are also passed to \code{ComplexHeatmap::Heatmap()}.}
}
\description{
Make multiple coverage heatmaps
}
\details{
This function takes a list of \code{normalizedMatrix} objects,
usually the output of \code{coverage_matrix2nmat()}, and
produces multiple heatmaps using
\code{EnrichedHeatmap}.

This function is intended to be a convenient wrapper to
help keep each data matrix in order, to apply consistent
clustering and filtering across all data matrices,
and to enable optional multi-row heatmap layout.
}
\examples{
## There is a small example file to use for testing
cov_file1 <- system.file("data", "tss_coverage.matrix", package="platjam");
cov_file2 <- system.file("data", "h3k4me1_coverage.matrix", package="platjam");
cov_files <- c(cov_file1, cov_file2);
names(cov_files) <- gsub("[.]matrix",
   "",
   basename(cov_files));
nmatlist <- lapply(cov_files, coverage_matrix2nmat);
nmatlist2heatmaps(nmatlist);

# k-means clusters
nmatlist2heatmaps(nmatlist, k_clusters=4);

# multiple rows
nmatlist2heatmaps(nmatlist, k_clusters=4, hm_nrow=2);

}
\seealso{
Other jam genome functions: \code{\link{coverage_matrix2nmat}}
}
\concept{jam genome functions}
