% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/platjam-import.R
\name{nmatlist2heatmaps}
\alias{nmatlist2heatmaps}
\title{Make multiple coverage heatmaps}
\usage{
nmatlist2heatmaps(
  nmatlist,
  panel_groups = NULL,
  title = NULL,
  caption = NULL,
  upstream_length = NULL,
  downstream_length = NULL,
  k_clusters = 0,
  min_rows_per_k = 25,
  k_subset = NULL,
  k_colors = NULL,
  k_width = grid::unit(5, "mm"),
  k_method = c("euclidean", "pearson", "correlation"),
  k_heatmap = main_heatmap,
  partition = NULL,
  rows = NULL,
  row_order = NULL,
  nmat_colors = NULL,
  middle_color = "white",
  nmat_names = NULL,
  main_heatmap = 1,
  anno_df = NULL,
  byCols = NULL,
  color_sub = NULL,
  anno_row_marks = NULL,
  anno_row_labels = NULL,
  top_annotation = NULL,
  top_anno_height = grid::unit(3, "cm"),
  top_axis_side = c("right"),
  legend_max_ncol = 2,
  legend_base_nrow = 5,
  legend_max_labels = 40,
  show_heatmap_legend = TRUE,
  hm_nrow = 1,
  transform = "none",
  signal_ceiling = NULL,
  axis_name = NULL,
  axis_name_gp = grid::gpar(fontsize = 8),
  axis_name_rot = 90,
  column_title_gp = grid::gpar(fontsize = 12),
  lens = -2,
  anno_lens = 8,
  pos_line = FALSE,
  seed = 123,
  ht_gap = grid::unit(3, "mm"),
  profile_value = c("mean", "sum", "abs_mean", "abs_sum"),
  ylims = NULL,
  border = TRUE,
  iter.max = 20,
  use_raster = TRUE,
  raster_quality = 1,
  raster_by_magick = TRUE,
  do_plot = TRUE,
  legend_width = grid::unit(3, "cm"),
  trim_legend_title = TRUE,
  heatmap_legend_param = NULL,
  heatmap_legend_direction = "horizontal",
  annotation_legend_param = NULL,
  return_type = c("heatmaplist", "grid"),
  show_error = FALSE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{nmatlist}{\code{list} containing \code{normalizedMatrix} objects,
usually the output from \code{coverage_matrix2nmat()}.}

\item{panel_groups}{\code{character} vector with values for each \code{nmatlist}
entry, which defines groups of heatmap panels.
Each panel group shares:
\itemize{
\item numeric range for the heatmap color gradient, defined by the first
\code{signal_ceiling} value for the group. Standard rules apply, such that
values below 1 represent a quantile signal threshold, and values above 1
represent a fixed numeric threshold.
\item one color key, labeled by \code{names(panel_groups)} to represent all
panels in the group
\item \code{ylim} y-axis range for the profile plot, either determined dynamically
or by the first \code{ylim} provided for the panel group
\item When \code{nmat_colors} is not defined, each panel group is assigned
one categorical color which is applied to all heatmaps in the group.
\item When \code{nmat_colors} is defined, each panel uses the color as defined,
however the color key only uses the color gradient from the first
panel in the group.
}}

\item{title, caption}{\code{character} string used as an overall title or
caption, respectively, displayed at the top of all heatmap output.}

\item{upstream_length, downstream_length}{\code{numeric} optional range of
coordinates to display across all heatmaps. This argument is intended
when the input \code{nmatlist} contains a wider range of coordinates
than should be displayed. The columns in \code{nmatlist} are subset
to retain only those columns within the range \code{downstream_length}
to \code{upstream_length}, assuming the middle coordinate is zero.
This step calls \code{zoom_nmatlist()}.
Note this step does not expand the displayed region.}

\item{k_clusters}{\code{integer} number of k-means clusters to
use to partition each heatmap. Use \code{0} or \code{NULL} for
no clustering.
Note \code{k_clusters} can be a vector, in which case it is applied
across unique groupings defined in \code{partition} if provided.
In this case if all unique values in \code{partition} are defined
by \code{names(k_clusters)} they are assigned by name, otherwise
\code{k_clusters} is recycled to the number of unique partition values,
and assigned in order. When \code{partition} is a \code{factor} the order
will honor \code{levels(partition)}.}

\item{min_rows_per_k}{\code{numeric} minimum rows required per k-means
cluster, used only when \code{k_clusters} is greater than 1.
With default \code{min_rows_per_k=25}, a partition with 25 or fewer rows
can only have \code{k=1}, and partition with 26 rows can have \code{k=2}.
This limit protects from k-means clustering small partitions.}

\item{k_subset}{\code{integer} vector of k-means clusters to
retain. This option is intended when only \code{k_clusters} is provided,
and not together with \code{partition}. This argument is intended to
"zoom in" to one or more k-means clusters of interest as a drill down
technique.}

\item{k_colors}{\code{character} vector of R colors, or \code{NULL} to use
the output of \code{colorjam::rainbowJam(k_clusters)}.}

\item{k_width}{\code{unit} width of the k-means cluster color
bar, used with \code{k_clusters}.}

\item{k_method}{\code{character} string indicating the distance
used by k-means, where the common default is
\code{"euclidean"}, however a useful alternative for
sequence coverage data is \code{"correlation"} as implemented
in \code{amap::Kmeans()}.}

\item{k_heatmap}{\code{integer} with one or more values indicating which
\code{nmatlist} entries to use for k-means clustering, used only when
\code{k_clusters} is greater than 1. This argument is useful for
applying clustering across multiple coverage heatmaps.}

\item{partition}{\code{character} or \code{factor} vector used to split rows
of each matrix in \code{nmatlist}, named by rownames.
This value is converted to \code{factor}, and will honor provided
factor levels.
\itemize{
\item When \code{partition} and \code{k_clusters} are both defined, the
data is first grouped by \code{partition} then each partition group
is separately k-means clustered, using rules described for
\code{k_clusters} and \code{min_rows_per_k}.
Colors are assigned to each partition value, then colors are split
by k clusters using \code{jamba::color2gradient()}.
}}

\item{rows}{\code{character} optional vector of rownames to subset from
\code{nmatlist}; or \code{integer} vector with row index values.
Note that even when using a subset of \code{rows} the data may also be
subset based upon available \code{names(partition)} and
\code{rownames(anno_df)}.}

\item{row_order}{\code{integer} vector used to order rows, intended to
allow ordering data based upon a specific heatmap, or using
different logic than the default.
\itemize{
\item When \code{row_order=NULL} (default) or \code{TRUE} it calls
\code{EnrichedHeatmap::enriched_score()} using data from \code{main_heatmap}.
This function generates a weighted score with heighest weight at
the center position, with progressively lower weight working outward
where the maximum distance has zero weight. The technique sorts signal
which emphasizes highest enriched signal at the center of the matrix.
\item When \code{row_order=FALSE} the data is ordered in the same order
they appear in \code{nmatlist}, or when \code{anno_df} and \code{byCols} are supplied,
the rows in \code{anno_df} are sorted using
\code{jamba::mixedSort(anno_df, byCols=byCols)} and the resulting row order
is used.
}}

\item{nmat_colors}{\code{character} vector of R colors,
to colorize each heatmap.
\itemize{
\item When \code{nmat_colors=NULL} (default) and \code{panel_groups} is not defined,
\code{colorjam::rainbowJam()} is used to assign one unique color
to each heatmap panel.
\item When \code{nmat_colors=NULL} and \code{panel_groups} is defined,
\code{colorjam::rainbowJam()} is used to assign one unique color
to each unique panel group, and the same color is applied to each
heatmap panel in each panel group.
}}

\item{middle_color}{\code{character} R color, default \code{middle_color="white"},
used as the middle color when creating a divergent color gradient.
This color should usually be either \code{"white"} or \code{"black"}, but
sometimes can be slightly off-white or off-black to apply some
distinction from the background color.}

\item{nmat_names}{\code{character} vector, or \code{NULL}, optional,
used as custom names for each heatmap in \code{nmatlist}.
When \code{nmat_names=NULL} the \code{signal_name} values are
used from each \code{nmatlist} entry attribute: \code{attr(nmat, "signal_name")}}

\item{main_heatmap}{\code{integer} index to define one entry in \code{nmatlist}
as the main heatmap used for clustering and row ordering.
Note that \code{k_heatmap} will override this option when provided.}

\item{anno_df}{\code{data.frame} or object that can be coerced to \code{data.frame}
whose \code{rownames(anno_df)} must match rownames in the nmatlist data.
\itemize{
\item Data can optionally be sorted by defining \code{byCols}.
\item When provided, data in \code{nmatlist} is automatically subsetted
to the matching \code{rownames(anno_df)} also present in \code{nmatlist}.
\item When \code{rows} is also defined, the data will be subsetted by
the \code{rows} and by the \code{rownames(anno_df)} present in \code{nmatlist}.
}}

\item{byCols}{\code{character} vector of \code{colnames(anno_df)} used to
sort the \code{data.frame}. This argument is passed to
\code{jamba::mixedSortDF()} and follows its rules, for example prefix \code{"-"}
causes the column to be sorted in reverse. Multiple columns can be
sorted, in the order they are provided, and factor levels are
honored for factor columns.}

\item{color_sub}{accepts input in two forms:
\enumerate{
\item \code{character} vector of R colors named by \code{character} values
\item \code{list} output from \code{design2colors()} where each \code{list} element
is named by colnames present in \code{anno_df},
and each \code{list} value is either:
\itemize{
\item \code{character} vector of colors named by \code{character} value, or
\item color \code{function} as defined by \code{circlize::colorRamp2()},
which takes a \code{numeric} value and returns a \code{character} R color.
}
}
\itemize{
\item When values for any column in \code{anno_df} does not have colors
assigned by one mechanism above, colors are assigned using
\code{colorjam::group2colors()}.
\item When \code{partition} is defined, colors are assigned either by
matching unique partition values with \code{names(color_sub)},
or with \code{attr(color_sub, "color_sub")} if present, which may contain
the full set of name-color assignments when \code{color_sub} is
provided as a \code{list}. Otherwise if \code{color_sub} is provided as a \code{list}
each entry is compared with \code{partition} values until values can
be fully matched. Failing these steps, colors are assigned to
unique \code{partition} values, then if \code{k_clusters} is also supplied,
the partition colors are then split by \code{colorjam::color2gradient()}
across the k-means clusters for each partition.
}}

\item{anno_row_marks}{\code{character} optional vector of \code{rownames}
in \code{nmatlist} that should be labeled beside the heatmaps using
\code{ComplexHeatmap::anno_mark()}.
\itemize{
\item Note \code{anno_row_labels} can be used to supply custom labels,
or one or more columns in \code{anno_df}.
\item When \code{anno_row_labels=NULL} (default) it displays the value
in \code{anno_row_marks} itself.
}}

\item{anno_row_labels}{\code{character} vector of optional labels to use
when \code{anno_row_marks} is supplied.
\itemize{
\item When \code{anno_row_labels=NULL} (default) it uses rownames defined
in `anno_row_marks.
\item It can be a \code{character} vector of actual labels, with names
that match \code{anno_row_marks} (thus rownames in \code{nmatlist}).
\item It can be a \code{character} vector with one or more \code{colnames(anno_df)},
which creates labels by concatenating values across columns,
delimited with space \code{" "}.
}}

\item{top_annotation}{\code{HeatmapAnnotation} or \code{logical} or \code{list}:
\itemize{
\item \code{top_annotation=TRUE} (default) uses the default
\code{EnrichedHeatmap::anno_enriched()} to display the signal profile
for each row partition and/or k-means cluster.
\item \code{top_annotation=FALSE} does not display a top annotation.
\item object \code{HeatmapAnnotation} as produced by
\code{ComplexHeatmap::HeatmapAnnotation(EnrichedHeatmap::anno_enriched())}
or equivalent. This form is required for the annotation
function to be called successfully on each heatmap in \code{nmatlist}.
\item a \code{list} of objects to be applied sequentially to
each \code{nmatlist} coverage heatmap in order, intended to allow custom
top annotation for each heatmap.
}}

\item{top_anno_height}{\code{unit} object to define the default
height of the \code{top_annotation}. When \code{top_annotation}
is not defined, the default method uses
\code{EnrichedHeatmap::anno_enriched()} with
\code{height=top_anno_height}.}

\item{top_axis_side}{\code{character} value indicating which side
of the top annotation to place the y-axis labels.
\itemize{
\item When only one value is defined, it is recycled across \code{nmatlist}.
\item Otherwise it is used when \code{panel_groups} are defined,
and the top annotation is labeled for only one panel in
each panel group using the side as defined. Labels are displayed
for each contiguous set of panel groups, so that heatmaps
in the same panel group can be ordered in different subsets.
Consider panel groups in this order: A, A, B, B, A, A. It would
display one set of axis labels for the first two panels in A, then
one axis label for the next two panels in B, then one axis label
again for the final two panels in A.
\item Values should be one of:
\itemize{
\item \code{"left"},\code{"right"}: axis labels on this side of each panel group
\item \code{"both"}: axis labels on both sides of each panel group, useful
when panel groups have a fairly large number of panels.
\item \code{"none"}: display no axis labels
\item \code{"all"}: display axis labels for every panel even within panel group.
}
}}

\item{legend_max_ncol}{\code{integer} number indicating the maximum
number of columns allowed for a categorical color legend.}

\item{legend_base_nrow}{integer number indicating the base
number of rows used for a categorical color legend, before
additional columns are added. Once the number of elements
exceeds \code{(legend_max_ncol * legend_base_nrow)} then
rows are added, but columns never exceed \code{legend_max_ncol}.}

\item{legend_max_labels}{\code{integer} to define the maximum labels
to display as a color legend. When any \code{anno_df} column contains
more than this number of categorical colors, the legend is
not displayed, in order to prevent the color legend from filling
the entire plot device, thus hiding the heatmaps.}

\item{hm_nrow}{\code{integer} number of rows used to display
the heatmap panels. This mechanism is somewhat experimental,
and is used to split a large number of coverage heatmaps into
two rows of heatmaps.
\itemize{
\item The matrix data row order is consistent across all heatmap panels.
\item The annotation data is displayed to the left of each row of
heatmap panels.
}}

\item{transform}{either \code{character} string referring to
a numeric transformation, or a \code{function} that applies
a numeric transformation. Valid \code{character} string values:
\code{"log2signed"} applies \code{jamba::log2signed()} which applies
\code{log2(1+x)} transform to the absolute value, then multiplies
by the original \code{sign(x)}; \code{"sqrt"} applies square root;
\code{"cubert"} applies cube root \code{x^(1/3)}; \code{"qrt"} applies
fourth root \code{x^(1/4)}. When there are negative numeric
values, the transformation is applied to absolute value,
then multiplied by the original sign. Therefore, the
transformation is applied to adjust the magnitude of
the values. These values are passed to \code{get_numeric_transform()}
which may have more information.}

\item{signal_ceiling}{\code{numeric} vector whose values are recycled
to length \code{length(nmatlist)}. The signal_ceiling
applies a maximum numeric value to the
color ramp for each matrix in \code{nmatlist}. The value is
passed to \code{get_nmat_ceiling()}, which recognizes three
numeric forms:
\itemize{
\item \code{signal_ceiling > 1}: this specific numeric value
is applied as the ceiling
\item \code{signal_ceiling > 0} and \code{signal_ceiling <= 1}: this numeric
value is interpreted as a quantile threshold, for example
\code{signal_ceiling=0.75} would calculate ceiling \code{quantile(x, probs=0.75)}.
\item \code{signal_ceiling} is \code{NULL}: the maximum absolute value of each
matrix is used as the ceiling.
}

Note that the ceiling is only applied to color scale and
not to the underlying data, which is useful to know because any
clustering and row ordering steps will use the full data
as needed.

If data needs to be strictly controlled to a
numeric ceiling, that processing should take place
on \code{nmatlist} before calling \code{nmatlist2heatmaps()}.}

\item{axis_name_gp}{x-axis label graphic parameters,
as output from \code{grid::gpar()}. For example to define
the x-axis font size, use the form
\code{grid::gpar(fontsize=8)}.}

\item{axis_name_rot}{numeric value either \code{0} or \code{90} indicating
whether to rotate the x-axis names, where \code{90} will rotate
labels, and \code{0} will leave labels horizontal.}

\item{column_title_gp}{heatmap title graphic parameters,
as output from \code{grid::gpar()}. For example to define
the x-axis font size, use the form
\code{grid::gpar(fontsize=8)}. This argument is passed
directly to \code{ComplexHeatmap::Heatmap()}.}

\item{lens}{numeric value used to scale each heatmap
color ramp, using \code{getColorRamp()}. Values above zero
apply the color gradient more rapidly starting from the
lowest value, making the color appear more intense for
lower numeric values. Values below zero apply the color gradient
less rapidly, which makes lower numeric values appear
less intense. This adjustment is intended to help
apply suitable color contrast depending upon the range
of numeric values. The \code{lens} values are applied to
each matrix in \code{nmatlist}, and so it is recycled to
\code{length(nmatlist)} as needed. Note that \code{signal_ceiling}
is also intended to help apply the color gradient to
a suitable numeric range, and the \code{lens} argument is
applied relative to the numeric range being used.}

\item{anno_lens}{numeric value used to scale the annotation
heatmap color scales, see \code{lens} for details. Values
higher than 1 make the color gradient more intense,
values below -1 make the color gradient less intense.}

\item{seed}{numeric value used with \code{set.seed()} to
set the random seed. Set to \code{NULL} to avoid running
\code{set.seed()}.}

\item{ht_gap}{\code{unit} size to specify the gap between multiple heatmaps.
This argument is passed to \code{ComplexHeatmap::draw()}. An example
is \code{grid::unit(8, "mm")} to specify 8 millimeters.}

\item{profile_value}{character string to define the type of numeric
profile to display at the top of each heatmap. This argument is
passed to \code{EnrichedHeatmap::anno_enriched()}. Values: \code{"mean"} the
mean profile; \code{"sum"} the sum; \code{"abs_sum"} sum of absolute values;
\code{"abs_mean"} the mean of absolute values.}

\item{ylims}{\code{vector} of maximum y-axis values for each heatmap profile;
or \code{list}}

\item{border}{\code{logical} indicating whether to draw a border around the
heatmap, which includes all heatmap panels in the event of
splitting by clustering. The \code{border} can be supplied as a vector,
so the \code{border} can be applied specifically to each heatmap
if needed.}

\item{iter.max}{integer value indicating the maximum iterations
performed by k-means clustering, only relevant when \code{k_clusters}
is non-zero.}

\item{use_raster}{logical indicating whether to create heatmaps
using raster resizing, almost always recommended \code{TRUE}.}

\item{raster_quality}{\code{logical} passed to \code{ComplexHeatmap::Heatmap()},
used when \code{use_raster=TRUE} and defines the level of detail retained,
and is used only when \code{raster_by_magick=FALSE}. Using larger numbers
decreases speed substantially.}

\item{raster_by_magick}{\code{logical} passed to \code{ComplexHeatmap::Heatmap()},
to enable ImageMagick use during rasterization. By default this
option is \code{TRUE} and is only disabled when the R package
\code{"magick"} is not installed, or not properly configured.
If you see a warning "instalilng 'magick' will improve rasterization"
then check the R package with \code{library(magick)} and see if
there are error messages. When \code{"magick"} is not available,
the rasterization is substantially slower, and may produce
files much larger than normal.}

\item{do_plot}{logical indicating whether to draw the heatmaps,
where \code{FALSE} will return the data used to create heatmaps
without actually drawing the heatmaps.}

\item{return_type}{character string indicating the type of
data to return: \code{"heatmaplist"} returns the list of heatmaps,
which can separately be arranged together using
\code{ComplexHeatmap::draw()} or \code{grid::grid.draw()}.}

\item{show_error}{logical indicating whether to add error
bars to the profile plot at the top of each heatmap.
These error bars are calculated by
\code{EnrichedHeatmap::anno_enriched()} using
\code{matrixStats::colSds(x)/nrow(x)}.}

\item{verbose}{logical indicating whether to print verbose output.}

\item{...}{additional arguments are passed to
\code{EnrichedHeatmap::EnrichedHeatmap()} to allow greater
customization of details. Note that many \code{...} arguments
are also passed to \code{ComplexHeatmap::Heatmap()}.}
}
\description{
Make multiple coverage heatmaps
}
\details{
This function takes a list of \code{normalizedMatrix} objects,
usually the output of \code{coverage_matrix2nmat()}, and
produces multiple heatmaps using
\code{EnrichedHeatmap}.

This function is intended to be a convenient wrapper to
help keep each data matrix in order, to apply consistent
clustering and filtering across all data matrices,
and to enable optional multi-row heatmap layout.
}
\examples{
## There is a small example file to use for testing
# library(jamba)
cov_file1 <- system.file("data", "tss_coverage.matrix", package="platjam");
cov_file2 <- system.file("data", "h3k4me1_coverage.matrix", package="platjam");
cov_files <- c(cov_file1, cov_file2);
names(cov_files) <- gsub("[.]matrix",
   "",
   basename(cov_files));
nmatlist <- lapply(cov_files, coverage_matrix2nmat);
nmatlist2heatmaps(nmatlist);

# sometimes data transform can be helpful
nmatlist2heatmaps(nmatlist,
   transform=c("log2signed", "sqrt"));

# k-means clusters, default uses euclidean distance
nmatlist2heatmaps(nmatlist, k_clusters=4,
   transform=c("log2signed", "sqrt"));

# k-means clusters, "correlation" or "pearson" sometimes works better
nmatlist2heatmaps(nmatlist,
   k_clusters=4,
   k_method="pearson",
   transform=c("log2signed", "sqrt"));

# example showing usage of top_axis_side
# and panel_groups
nmatlist2 <- nmatlist[c(1, 1, 1, 2, 2, 2)];
names(nmatlist2) <- jamba::makeNames(names(nmatlist2))
for (iname in names(nmatlist2)) {
   attr(nmatlist2[[iname]], "signal_name") <- gsub("coverage", "cov", iname);
}
# top_axis_side="left"
# assumes 12x7 figure size
nmatlist2heatmaps(nmatlist2,
   signal_ceiling=0.8,
   nmat_colors=rep(c("firebrick", "tomato"), each=3),
   panel_groups=rep(c("tss", "h3k4me1"), each=3),
   ht_gap=grid::unit(4, "mm"),
   top_axis_side="left",
   transform=rep(c("log2signed", "sqrt"), each=3));

# top_axis_side="both"
nmatlist2heatmaps(nmatlist2,
   panel_groups=rep(c("tss", "h3k4me1"), each=3),
   ht_gap=grid::unit(6, "mm"),
   top_axis_side="both",
   transform=rep(c("log2signed", "sqrt"), each=3));

# multiple heatmap rows
nmatlist2heatmaps(nmatlist2,
   k_clusters=4,
   k_method="pearson",
   hm_nrow=2,
   panel_groups=rep(c("tss", "h3k4me1"), each=3),
   ht_gap=grid::unit(6, "mm"),
   top_axis_side="both",
   top_anno_height=grid::unit(0.8, "cm"),
   transform=rep(c("log2signed", "sqrt"), each=3));

# invent anno_df data.frame of additional annotations
anno_df <- data.frame(
   tss_score=EnrichedHeatmap::enriched_score(jamba::log2signed(nmatlist[[1]])),
   h3k4me1_score=EnrichedHeatmap::enriched_score(jamba::log2signed(nmatlist[[2]]))
);
rownames(anno_df) <- rownames(nmatlist[[1]]);
nmatlist2heatmaps(nmatlist,
   title="k-means clustering across both heatmaps",
   k_clusters=4,
   k_method="pearson",
   k_heatmap=c(1, 2),
   ht_gap=grid::unit(6, "mm"),
   top_axis_side="left",
   anno_df=anno_df,
   transform=rep(c("log2signed", "sqrt"), each=3));

}
\seealso{
Other jam coverage heatmap functions: 
\code{\link{coverage_matrix2nmat}()},
\code{\link{get_nmat_ceiling}()},
\code{\link{nmathm_row_order}()},
\code{\link{validate_heatmap_params}()},
\code{\link{zoom_nmatlist}()},
\code{\link{zoom_nmat}()}
}
\concept{jam coverage heatmap functions}
