% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/platjam-import.R
\name{nmatlist2heatmaps}
\alias{nmatlist2heatmaps}
\title{Make multiple coverage heatmaps}
\usage{
nmatlist2heatmaps(
  nmatlist,
  panel_groups = NULL,
  title = NULL,
  caption = NULL,
  k_clusters = 0,
  k_subset = NULL,
  k_colors = NULL,
  k_width = unit(5, "mm"),
  k_method = c("euclidean", "pearson", "correlation"),
  partition = NULL,
  rows = NULL,
  row_order = NULL,
  nmat_colors = NULL,
  middle_color = "white",
  nmat_names = NULL,
  main_heatmap = 1,
  anno_df = NULL,
  byCols = NULL,
  anno_row_marks = NULL,
  anno_row_labels = NULL,
  hm_nrow = 1,
  transform = "none",
  signal_ceiling = NULL,
  axis_name = NULL,
  axis_name_gp = grid::gpar(fontsize = 8),
  axis_name_rot = 90,
  column_title_gp = grid::gpar(fontsize = 12),
  lens = -2,
  seed = 123,
  ht_gap = grid::unit(7, "mm"),
  profile_value = c("mean", "sum", "abs_mean", "abs_sum"),
  ylims = NULL,
  border = TRUE,
  iter.max = 20,
  use_raster = TRUE,
  do_plot = TRUE,
  legend_width = grid::unit(3, "cm"),
  heatmap_legend_param = NULL,
  annotation_legend_param = NULL,
  return_type = c("heatmaplist", "grid"),
  show_error = FALSE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{nmatlist}{\code{list} containing \code{normalizedMatrix} objects,
usually the output from \code{coverage_matrix2nmat()}.}

\item{k_clusters}{integer number of k-means clusters to
use to partition each heatmap. Use \code{0} or \code{NULL} for
no clustering.}

\item{k_subset}{integer vector of k-means clusters to
retain. Often one cluster contains mostly empty
values, and can be removed using this mechanism.}

\item{k_colors}{vector of R colors, or \code{NULL} to use
the output of \code{colorjam::rainbowJam(k_clusters)}.}

\item{k_width}{unit width of the k-means cluster color
bar, used with \code{k_clusters}.}

\item{partition}{vector used to split rows of each
matrix in \code{nmatlist}, named by rownames. This
value is ignored when \code{k_clusters} is supplied.}

\item{rows}{vector of \code{rownames} or integer vector with
index of rows to keep from each matrix in \code{nmatlist}.}

\item{row_order}{integer vector used to order rows.
When \code{TRUE} or \code{NULL} it uses
the default for \code{EnrichedHeatmap::EnrichedHeatmap()}
which is the \code{EnrichedHeatmap::enriched_score()}
for the matrix \code{main_heatmap}. When \code{FALSE} the
rows are ordered by the order they appear in \code{rows},
which is either the order they appear in \code{nmatlist}
or the order after sorting \code{anno_df}. When
\code{TRUE} the default}

\item{nmat_colors}{named character vector of R colors,
to colorize each heatmap. When \code{NULL} then
\code{colorjam::rainbowJam()} is used to create colors
for each heatmap panel.}

\item{middle_color}{\code{character} R compatible color used
when creating a divergent color gradient, this color
is used as the middle color. Usually this color should
be either \code{"white"} or \code{"black"}.}

\item{nmat_names}{\code{character} vector, or \code{NULL}, optional,
used as custom names for each heatmap in \code{nmatlist}.
When \code{nmat_names=NULL} the \code{signal_name} values are
used from each \code{nmatlist} matrix.}

\item{main_heatmap}{integer index referring to the
entry in \code{nmatlist} to use for clustering and row
ordering.}

\item{anno_df}{\code{data.frame} or object that can be coerced,
used to annotate rows of each matrix. It must have
\code{rownames(anno_df)} that match \code{rownames(nmatlist)}.
When supplied, data can be sorted using \code{byCols}.
Note that only the \code{rownames(anno_df)}
present in both \code{nmatlist} and \code{anno_df} are
used to display the heatmaps. These rows
may also be subsetted using argument \code{rows}.}

\item{byCols}{character vector of  values in
\code{colnames(anno_df)} used to sort the data.frame
via \code{jamba::mixedSortDF()}. Any colname with
prefix \code{-} will be reverse-sorted.}

\item{anno_row_marks}{character vector of \code{rownames}
which will be labeled beside the heatmaps, using
the \code{ComplexHeatmap::anno_mark()} method. It currently
requires \code{anno_df} be defined, since it uses the
first column in \code{anno_df} as a one-column heatmap,
to anchor the labels.}

\item{anno_row_labels}{character vector of optional
character labels to use instead of \code{rownames}.
If \code{NULL} then \code{anno_row_marks} are used. Or
\code{anno_row_labels} may contain a character vector
of \code{colnames(anno_df)} which will create labels
by concatenating each column value separated by
space \code{" "}.}

\item{hm_nrow}{integer number of rows used to display
the heatmap panels.}

\item{transform}{either \code{character} string referring to
a numeric transformation, or a \code{function} that applies
a numeric transformation. Valid \code{character} string values:
\code{"log2signed"} applies \code{jamba::log2signed()} which applies
\code{log2(1+x)} transform to the absolute value, then multiplies
by the original \code{sign(x)}; \code{"sqrt"} applies square root;
\code{"cubert"} applies cube root \code{x^(1/3)}; \code{"qrt"} applies
fourth root \code{x^(1/4)}. When there are negative numeric
values, the transformation is applied to absolute value,
then multiplied by the original sign. Therefore, the
transformation is applied to adjust the magnitude of
the values. These values are passed to \code{get_numeric_transform()}
which may have more information.}

\item{signal_ceiling}{numeric vector length \code{length(nmatlist)}
which applies a maximum numeric value to the
color ramp for each matrix in \code{nmatlist}. Every numeric
value above the \code{signal_ceiling} will be assigned the
maximum color. The values in \code{signal_ceiling} are
recycled to \code{length(nmatlist)}, so if one value is
provided, it will be applied to every matrix.}

\item{axis_name_gp}{x-axis label graphic parameters,
as output from \code{grid::gpar()}. For example to define
the x-axis font size, use the form
\code{grid::gpar(fontsize=8)}.}

\item{axis_name_rot}{numeric value either \code{0} or \code{90} indicating
whether to rotate the x-axis names, where \code{90} will rotate
labels, and \code{0} will leave labels horizontal.}

\item{column_title_gp}{heatmap title graphic parameters,
as output from \code{grid::gpar()}. For example to define
the x-axis font size, use the form
\code{grid::gpar(fontsize=8)}. This argument is passed
directly to \code{ComplexHeatmap::Heatmap()}.}

\item{lens}{numeric value used to scale each heatmap
color ramp, using \code{getColorRamp()}. Values above zero
apply the color gradient more rapidly starting from the
lowest value, making the color appear more intense for
lower numeric values. Values below zero apply the color gradient
less rapidly, which makes lower numeric values appear
less intense. This adjustment is intended to help
apply suitable color contrast depending upon the range
of numeric values. The \code{lens} values are applied to
each matrix in \code{nmatlist}, and so it is recycled to
\code{length(nmatlist)} as needed. Note that \code{signal_ceiling}
is also intended to help apply the color gradient to
a suitable numeric range, and the \code{lens} argument is
applied relative to the numeric range being used.}

\item{seed}{numeric value used with \code{set.seed()} to
set the random seed. Set to \code{NULL} to avoid running
\code{set.seed()}.}

\item{ht_gap}{unit size to specify the gap between multiple heatmaps.
This argument is passed to \code{ComplexHeatmap::draw()}. An example
is \code{grid::unit(8, "mm")} to specify 8 millimeters.}

\item{profile_value}{character string to define the type of numeric
profile to display at the top of each heatmap. This argument is
passed to \code{EnrichedHeatmap::anno_enriched()}. Values: \code{"mean"} the
mean profile; \code{"sum"} the sum; \code{"abs_sum"} sum of absolute values;
\code{"abs_mean"} the mean of absolute values.}

\item{ylims}{\code{vector} of maximum y-axis values for each heatmap profile;
or \code{list}}

\item{border}{\code{logical} indicating whether to draw a border around the
heatmap, which includes all heatmap panels in the event of
splitting by clustering. The \code{border} can be supplied as a vector,
so the \code{border} can be applied specifically to each heatmap
if needed.}

\item{iter.max}{integer value indicating the maximum iterations
performed by k-means clustering, only relevant when \code{k_clusters}
is non-zero.}

\item{use_raster}{logical indicating whether to create heatmaps
using raster resizing, almost always recommended \code{TRUE}.}

\item{do_plot}{logical indicating whether to draw the heatmaps,
where \code{FALSE} will return the data used to create heatmaps
without actually drawing the heatmaps.}

\item{return_type}{character string indicating the type of
data to return: \code{"heatmaplist"} returns the list of heatmaps,
which can separately be arranged together using
\code{ComplexHeatmap::draw()} or \code{grid::grid.draw()}.}

\item{show_error}{logical indicating whether to add error
bars to the profile plot at the top of each heatmap.
These error bars are calculated by
\code{EnrichedHeatmap::anno_enriched()} using
\code{matrixStats::colSds(x)/nrow(x)}.}

\item{verbose}{logical indicating whether to print verbose output.}

\item{...}{additional arguments are passed to
\code{EnrichedHeatmap::EnrichedHeatmap()} to allow greater
customization of details. Note that many \code{...} arguments
are also passed to \code{ComplexHeatmap::Heatmap()}.}
}
\description{
Make multiple coverage heatmaps
}
\details{
This function takes a list of \code{normalizedMatrix} objects,
usually the output of \code{coverage_matrix2nmat()}, and
produces multiple heatmaps using
\code{EnrichedHeatmap}.

This function is intended to be a convenient wrapper to
help keep each data matrix in order, to apply consistent
clustering and filtering across all data matrices,
and to enable optional multi-row heatmap layout.
}
\examples{
## There is a small example file to use for testing
cov_file1 <- system.file("data", "tss_coverage.matrix", package="platjam");
cov_file2 <- system.file("data", "h3k4me1_coverage.matrix", package="platjam");
cov_files <- c(cov_file1, cov_file2);
names(cov_files) <- gsub("[.]matrix",
   "",
   basename(cov_files));
nmatlist <- lapply(cov_files, coverage_matrix2nmat);
nmatlist2heatmaps(nmatlist);

# k-means clusters
nmatlist2heatmaps(nmatlist, k_clusters=4);

# multiple rows
nmatlist2heatmaps(nmatlist, k_clusters=4, hm_nrow=2);

}
\seealso{
Other jam genome functions: 
\code{\link{coverage_matrix2nmat}()}
}
\concept{jam genome functions}
