% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/platjam-import.R
\name{nmatlist2heatmaps}
\alias{nmatlist2heatmaps}
\title{Make multiple coverage heatmaps}
\usage{
nmatlist2heatmaps(
  nmatlist,
  panel_groups = NULL,
  title = NULL,
  title_gp = grid::gpar(fontsize = 16),
  caption = NULL,
  upstream_length = NULL,
  downstream_length = NULL,
  k_clusters = 0,
  min_rows_per_k = 100,
  k_subset = NULL,
  k_colors = NULL,
  k_width = grid::unit(5, "mm"),
  k_method = c("correlation", "euclidean", "pearson", "spearman"),
  k_heatmap = main_heatmap,
  row_title_rot = 0,
  partition = NULL,
  partition_counts = TRUE,
  partition_count_template = "{partition_name}\\n({counts} rows)",
  partition_label = NULL,
  rows = NULL,
  row_order = NULL,
  nmat_colors = NULL,
  middle_color = "white",
  nmat_names = NULL,
  main_heatmap = NULL,
  anno_df = NULL,
  byCols = NULL,
  color_sub = NULL,
  anno_row_marks = NULL,
  anno_row_labels = NULL,
  anno_row_gp = grid::gpar(fontsize = 14),
  recenter_heatmap = NULL,
  summit_names = NULL,
  recenter_range = NULL,
  recenter_invert = FALSE,
  restrand_heatmap = NULL,
  restrand_range = NULL,
  restrand_buffer = NULL,
  restrand_invert = FALSE,
  top_annotation = NULL,
  top_anno_height = grid::unit(3, "cm"),
  top_axis_side = c("right"),
  legend_max_ncol = 2,
  legend_base_nrow = 12,
  legend_max_labels = 40,
  show_heatmap_legend = TRUE,
  heatmap_legend_param = NULL,
  heatmap_legend_direction = "horizontal",
  annotation_legend_param = NULL,
  hm_nrow = 1,
  transform = "none",
  transform_label = NULL,
  signal_ceiling = NULL,
  axis_name = NULL,
  axis_name_gp = grid::gpar(fontsize = 10),
  axis_name_rot = 90,
  column_title_gp = grid::gpar(fontsize = 14),
  lens = 0,
  anno_lens = 8,
  pos_line = FALSE,
  seed = 123,
  ht_gap = grid::unit(4, "mm"),
  row_anno_padding = grid::unit(4, "mm"),
  column_anno_padding = grid::unit(4, "mm"),
  legend_padding = grid::unit(1, "cm"),
  profile_value = c("mean", "sum", "abs_mean", "abs_sum"),
  profile_linetype = c(1, 5, 3),
  profile_linewidth = 1.5,
  ylims = NULL,
  border = TRUE,
  iter.max = 20,
  use_raster = TRUE,
  raster_quality = 1,
  raster_by_magick = jamba::check_pkg_installed("magick"),
  do_plot = TRUE,
  do_caption = TRUE,
  legend_fontsize = 10,
  legend_width = grid::unit(3, "cm"),
  trim_legend_title = TRUE,
  padding = grid::unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
  return_type = c("heatmaplist", "grid"),
  show_error = FALSE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{nmatlist}{\code{list} containing \code{normalizedMatrix} objects,
usually the output from \code{coverage_matrix2nmat()}.}

\item{panel_groups}{\code{character} vector with values for each \code{nmatlist}
entry, which defines groups of heatmap panels.
Each panel group shares:
\itemize{
\item numeric range for the heatmap color gradient, defined by the first
\code{signal_ceiling} value for the group. Standard rules apply, such that
values below 1 represent a quantile signal threshold, and values above 1
represent a fixed numeric threshold.
\item one color key, labeled by \code{names(panel_groups)} to represent all
panels in the group
\item \code{ylim} y-axis range for the profile plot, either determined dynamically
or by the first \code{ylim} provided for the panel group
\item When \code{nmat_colors} is not defined, each panel group is assigned
one categorical color which is applied to all heatmaps in the group.
\item When \code{nmat_colors} is defined, each panel uses the color as defined,
however the color key only uses the color gradient from the first
panel in the group.
}}

\item{title, caption}{\code{character} string used as an overall title or
caption, respectively, displayed at the top of all heatmap output.}

\item{title_gp}{\code{grid::gpar} object to customize the title fontsize,
fontface, color (col), etc.}

\item{upstream_length, downstream_length}{\code{numeric} (optional) range of
coordinates to display across all heatmaps. This argument is intended
when the input \code{nmatlist} contains a wider range of coordinates
than should be displayed. The columns in \code{nmatlist} are subset
to retain only those columns within the range \code{downstream_length}
to \code{upstream_length}, assuming the middle coordinate is zero.
This step calls \code{zoom_nmatlist()}.
Note this step does not expand the displayed region.}

\item{k_clusters}{\code{integer} number of k-means clusters to
use to partition each heatmap. Use \code{0} or \code{NULL} for
no clustering (default).
Note \code{k_clusters} can be a \code{numeric} vector, in which case it is applied
across unique groups defined by \code{partition} if provided.
If \code{names(k_clusters)} match values in \code{partition} they will be applied
by name, otherwise they are applied in the order the clusters are
defined by \code{partition}.
Each group is clustered to that many k clusters, provided it
also meets the threshold \code{min_row_per_k} - which is intended to prevent
clustering 10 rows into 10 k-means clusters.}

\item{min_rows_per_k}{\code{numeric} minimum rows required per k-means
cluster, used only when \code{k_clusters} is greater than 1.
With default \code{min_rows_per_k=10}, a partition with 100 or fewer rows
can only have \code{k=1}, and partition with 101 rows can have \code{k=2}.
This limit protects from k-means clustering small partitions.}

\item{k_subset}{\code{integer} vector of k-means clusters to retain.
This argument is intended to "zoom in" (or "drill down") to one
or more k-means clusters of interest.
When both \code{k_clusters} and \code{partition} are provided, this argument
must exactly match the row title as displayed in the heatmap.}

\item{k_colors}{\code{character} vector of R colors, or \code{NULL} to use
the output of \code{colorjam::rainbowJam(k_clusters)}.
These colors are applied to \code{k_clusters} and/or \code{partition}:
\itemize{
\item When \code{partition} is provided, \code{names(k_colors)} are used when present,
otherwise colors are assigned in order of \code{partition} groups.
When \code{k_clusters} is also defined, each partition color is split into
a light-to-dark gradient based upon the number of k_clusters.
\item When \code{partition} is not provided, \code{k_colors} are applied to k-means
clusters in the order the colors are provided.
}}

\item{k_width}{\code{unit} width of the k-means cluster color
bar, used with \code{k_clusters}, default is 5 mm width.}

\item{k_method}{\code{character} string indicating the distance
used by k-means, where the common default is
\code{"euclidean"}, however a useful alternative for
sequence coverage data is \code{"correlation"} as implemented
in \code{amap::Kmeans()}. Available methods:
\itemize{
\item \code{"euclidean"} (default) calculates the typical Euclidean distance,
which tends to emphasize total signal moreso than the specific
shape of the signal.
\item \code{"correlation"} when the R package \code{amap} is available, this method
emphasizes the shape of signal profiles, and is particularly effective.
It is also called "centered Pearson" since data is centered prior
to calculating correlation.
\item \code{"pearson"} when the R package \code{amap} is available, this method
is also called "not centered Pearson" since data is not centered
prior to calculating correlation.
\item \code{"spearman"} when the R package \code{amap} is available, this method
computes distance based upon rank differences. It has not been tested
much in this context.
}}

\item{k_heatmap}{\code{integer} with one or more values indicating which
\code{nmatlist} entries to use for k-means clustering,
default uses \code{main_heatmap}. This value is only used when
\code{k_clusters} is greater than 1. This argument is useful for
clustering multiple coverage heatmaps together.}

\item{row_title_rot}{\code{numeric} value in degrees, to rotate the
partition labels on the left, when either \code{partition} or
\code{k_clusters} are provided. The default \code{0} uses horizontal
text. For long labels, it may be better to use \code{30} or \code{60}.}

\item{partition}{\code{character} or \code{factor} vector used to split rows
of each matrix in \code{nmatlist}, and \strong{must named by rownames}
in \code{nmatlist}.
\itemize{
\item When NULL, and when \code{anno_df} is defined, it looks for partitioning
colnames: 'partition', 'group', 'row_split', and uses one or more
that match these values, case-insensitively. In this case, the vector
is created using \code{jamba::pasteByRowsOrdered()} which will preserve any
factor ordering that is present, and then names the vector by rownames.
\item When provided one or more \code{character} values that all match
\code{colnames(anno_df)}, it uses those values to generate a vector
named by \code{rownames(anno_df)}.
\item When \code{partition} and \code{k_clusters} are both defined, the
data is first grouped by \code{partition} then each partition group
is separately k-means clustered, using rules described for
\code{k_clusters} and \code{min_rows_per_k}.
\item Colors defined in \code{k_colors} are assigned to each partition value,
then colors are split to light-to-dark gradient
using \code{jamba::color2gradient()} for each k-means cluster, when
\code{k_clusters} is also defined with value greater than 1.
}}

\item{partition_counts}{\code{logical} indicating whether to include the
number of rows in each partition, default \code{TRUE}.
Note that this setting is active if \code{k_clusters} and/or \code{partition}
are supplied. Any situation where rows are split, the number of
rows will be displayed.}

\item{partition_count_template}{\code{character} format used when
\code{partition_counts=TRUE}, used together with \code{glue::glue()} to format
each row partition. The default: \code{"{partition_name}\\n({counts} rows)"}
will print for example: \code{"A\\n(125 rows)"}}

\item{partition_label}{\code{character} optional label used for the partition
annotation, default is NULL. When \code{anno_df} contains a partitioning
column, one or more are used for partitioning. In this case, when
\code{partition_label} is not defined, the colnames used for partitioning
are concatenated with '_' (underscore) and used to create the label.
Otherwise, the default becomes 'Cluster'.}

\item{rows}{optional vector to define subset rows, or specific row order:
\itemize{
\item \code{character} vector of rownames in \code{nmatlist}, or
\item \code{integer} vector with row numbers (row index) values.
}

Note that even when using a subset of \code{rows} the data may also be
subset based upon available \code{names(partition)} and
\code{rownames(anno_df)}.}

\item{row_order}{\code{integer} vector used to order rows, intended to
allow ordering data based upon a specific heatmap, or using
different logic than the default.
\itemize{
\item When \code{row_order=NULL} (default) or \code{row_order=TRUE} it calls
\code{EnrichedHeatmap::enriched_score()} using data from \code{main_heatmap}.
When there are multiple values for \code{main_heatmap} (which is default),
then scores are calculated for each matrix, then the average score
is used per row.
}

The \code{enriched_score()} function generates a weighted score with
heighest weight at the center position, with progressively lower
weight working outward where the maximum distance has zero weight.
The technique sorts signal which emphasizes highest enriched signal
at the center of the matrix.
\itemize{
\item When \code{row_order=FALSE} the data is ordered in the same order
they appear in \code{nmatlist}, or when \code{anno_df} and \code{byCols} are supplied,
the rows in \code{anno_df} are sorted using
\code{jamba::mixedSort(anno_df, byCols=byCols)} and the resulting row order
is used.
}}

\item{nmat_colors}{\code{character} vector of R colors,
to colorize each heatmap.
\itemize{
\item When \code{nmat_colors=NULL} (default) and \code{panel_groups} is not defined,
\code{colorjam::rainbowJam()} is used to assign one unique color
to each heatmap panel.
\item When \code{nmat_colors=NULL} and \code{panel_groups} is defined,
\code{colorjam::rainbowJam()} is used to assign one unique color
to each unique panel group, and the same color is applied to each
heatmap panel in each panel group.
}}

\item{middle_color}{\code{character} R color, default \code{middle_color="white"},
used as the middle color when creating a divergent color gradient.
This color should usually be either \code{"white"} or \code{"black"}, but
sometimes can be slightly off-white or off-black to apply some
distinction from the background color.}

\item{nmat_names}{\code{character} vector, or \code{NULL}, optional,
used as custom names for each heatmap in \code{nmatlist}.
When \code{nmat_names=NULL} the \code{signal_name} values are
used from each \code{nmatlist} entry attribute: \code{attr(nmat, "signal_name")}}

\item{main_heatmap}{\code{integer} index to define one or more entries
in \code{nmatlist} as the main heatmap used for clustering and row ordering.
Note that \code{k_heatmap} will override this option when provided.
By default \code{main_heatmap=NULL} will cause all heatmaps to be used for
row ordering.}

\item{anno_df}{\code{data.frame} or object that can be coerced to \code{data.frame}
whose \code{rownames(anno_df)} must match rownames in the nmatlist data.
When \code{rownames(anno_df)} does not match, this function fails with
an error message.
\itemize{
\item When \code{anno_df} is not supplied, and \code{attr(nmatlist, "anno_df")} is
defined, it is used as \code{anno_df} by default. This mechanism allows
importing data into nmatlist and defining appropriate \code{anno_df}
at the same time, then using it directly.
\item When \code{partition} is not defined, columns in \code{anno_df} may be used
for row partitioning, see info for argument \code{partition}.
\item Data can optionally be sorted by defining \code{byCols}.
\item When provided, data in \code{nmatlist} is automatically subsetted
to the matching \code{rownames(anno_df)} also present in \code{nmatlist}.
\item When \code{rows} is also defined, the data will be subsetted by
the \code{rows} and by the \code{rownames(anno_df)} present in \code{nmatlist}.
}}

\item{byCols}{\code{character} vector of \code{colnames(anno_df)} used to
sort the \code{data.frame}. This argument is passed to
\code{jamba::mixedSortDF()} and follows its rules, for example prefix \code{"-"}
causes the column to be sorted in reverse. Multiple columns can be
sorted, in the order they are provided, and factor levels are
honored for factor columns.}

\item{color_sub}{accepts input in two forms:
\enumerate{
\item \code{character} vector of R colors named by \code{character} values
\item \code{list} output from \code{design2colors()} where each \code{list} element
is named by colnames present in \code{anno_df},
and each \code{list} value is either:
\itemize{
\item \code{character} vector of colors named by \code{character} value, or
\item color \code{function} as defined by \code{circlize::colorRamp2()},
which takes a \code{numeric} value and returns a \code{character} R color.
}
}
\itemize{
\item When values for any column in \code{anno_df} does not have colors
assigned by one mechanism above, colors are assigned using
\code{colorjam::group2colors()}.
\item When \code{partition} is defined, colors are assigned either by
matching unique partition values with \code{names(color_sub)},
or with \code{attr(color_sub, "color_sub")} if present, which may contain
the full set of name-color assignments when \code{color_sub} is
provided as a \code{list}. Otherwise if \code{color_sub} is provided as a \code{list}
each entry is compared with \code{partition} values until values can
be fully matched. Failing these steps, colors are assigned to
unique \code{partition} values, then if \code{k_clusters} is also supplied,
the partition colors are then split by \code{colorjam::color2gradient()}
across the k-means clusters for each partition.
}}

\item{anno_row_marks}{\code{character} optional vector of \code{rownames}
in \code{nmatlist} that should be labeled beside the heatmaps using
\code{ComplexHeatmap::anno_mark()}.
\itemize{
\item Note \code{anno_row_labels} can be used to supply custom labels,
or one or more columns in \code{anno_df}.
\item When \code{anno_row_labels=NULL} (default) it displays the value
in \code{anno_row_marks} itself.
}}

\item{anno_row_labels}{\code{character} vector of optional labels to use
when \code{anno_row_marks} is supplied.
\itemize{
\item When \code{anno_row_labels=NULL} (default) it uses rownames defined
in `anno_row_marks.
\item It can be a \code{character} vector of actual labels, with names
that match \code{anno_row_marks} (thus rownames in \code{nmatlist}).
\item It can be a \code{character} vector with one or more \code{colnames(anno_df)},
which creates labels by concatenating values across columns,
delimited with space \code{" "}.
}}

\item{anno_row_gp}{\code{grid::gpar} object used to customize the text label
displayed when \code{anno_row_marks} is defined. The default fontsize 14
is intended to be larger than other default values, for legibility.}

\item{recenter_heatmap, recenter_range, recenter_invert}{arguments
are passed to \code{recenter_nmatlist()} to apply re-centering.
\itemize{
\item Note that recenter will always occur before restrand.
}}

\item{summit_names}{\code{character} default NULL, optional colnames to
use for recentering, which applies a previously defined set of
summit positions to use. It ignores all other recenter arguments.}

\item{restrand_heatmap, restrand_range, restrand_buffer, restrand_invert}{arguments are passed to \code{restrand_nmatlist()} to apply re-stranding.
\itemize{
\item Note that recenter will always occur before restrand.
}}

\item{top_annotation}{\code{HeatmapAnnotation} or \code{logical} or \code{list}:
\itemize{
\item \code{top_annotation=TRUE} (default) uses the default
\code{EnrichedHeatmap::anno_enriched()} to display the signal profile
for each row partition and/or k-means cluster.
\item \code{top_annotation=FALSE} does not display a top annotation.
\item object \code{HeatmapAnnotation} as produced by
\code{ComplexHeatmap::HeatmapAnnotation(EnrichedHeatmap::anno_enriched())}
or equivalent. This form is required for the annotation
function to be called successfully on each heatmap in \code{nmatlist}.
\item a \code{list} of objects to be applied sequentially to
each \code{nmatlist} coverage heatmap in order, intended to allow custom
top annotation for each heatmap.
}}

\item{top_anno_height}{\code{unit} object to define the default
height of the \code{top_annotation}. When \code{top_annotation}
is not defined, the default method uses
\code{EnrichedHeatmap::anno_enriched()} with
\code{height=top_anno_height}.}

\item{top_axis_side}{\code{character} value indicating which side
of the top annotation to place the y-axis labels.
\itemize{
\item When only one value is defined, it is recycled across \code{nmatlist}.
\item Otherwise it is used when \code{panel_groups} are defined,
and the top annotation is labeled for only one panel in
each panel group using the side as defined. Labels are displayed
for each contiguous set of panel groups, so that heatmaps
in the same panel group can be ordered in different subsets.
Consider panel groups in this order: A, A, B, B, A, A. It would
display one set of axis labels for the first two panels in A, then
one axis label for the next two panels in B, then one axis label
again for the final two panels in A.
\item Values should be one of:
\itemize{
\item \code{"left"},\code{"right"}: axis labels on this side of each panel group
\item \code{"both"}: axis labels on both sides of each panel group, useful
when panel groups have a fairly large number of panels.
\item \code{"none"}: display no axis labels
\item \code{"all"}: display axis labels for every panel even within panel group.
}
}}

\item{legend_max_ncol}{\code{integer} number indicating the maximum
number of columns allowed for a categorical color legend.}

\item{legend_base_nrow}{\code{integer} number indicating the base
number of rows used for a categorical color legend, before
additional columns are added. Once the number of elements
exceeds \code{(legend_max_ncol * legend_base_nrow)} then
rows are added, but columns never exceed \code{legend_max_ncol}.}

\item{legend_max_labels}{\code{integer} to define the maximum labels
to display as a color legend. When any \code{anno_df} column contains
more than this number of categorical colors, the legend is
not displayed, in order to prevent the color legend from filling
the entire plot device, thus hiding the heatmaps.}

\item{show_heatmap_legend}{\code{logical} indicating whether to display the
color legend for each heatmap entry in \code{nmatlist}. When \code{panel_groups}
are supplied, color legends are displayed only for the first
heatmap in each unique panel group, unless \code{show_heatmap_legend=FALSE},
or unless \code{show_heatmap_legend} is already defined for every heatmap.}

\item{heatmap_legend_param}{\code{list} with optional heatmap legend settings.
By default \code{NULL} causes this argument to be defined internally,
however when provided it overrides any internal settings and is used
directly. The \code{list} should be \code{length(nmatlist)}, or is recycled
to that length.}

\item{heatmap_legend_direction}{\code{character} string used when
\code{show_heatmap_legend=TRUE} and \code{heatmap_legend_param} is not already
provided.
\itemize{
\item By default \code{heatmap_legend_direction="horizontal"} displays
the color gradient in the legend horizontally as a continuous scale,
with labels defined in \code{EnrichedHeatmap::EnrichedHeatmap()}, and
width equal to \code{grid::unit(1, "npc")} which uses the full width of
the color legend area.
\item When \code{heatmap_legend_direction="vertical"} the color legend is
displayed vertically, with width \code{grid::unit(5, "mm")}.
}}

\item{annotation_legend_param}{\code{list} optional parameters passed to
the annotation legend functions, intended to provide customization.
The \code{list} should be named by each annotation entry to be customized,
and any annotation entries not defined \code{annotation_legend_param}
use the default behavior of \code{ComplexHeatmap::HeatmapAnnotation()},
which will assign its own set of colors and use default legend
parameters by default.
When \code{annotation_legend_param=NULL} (default) then all colors
are defined, and all legends are displayed using this function
defaults. When there are more labels than \code{legend_max_labels}
the color legend will be hidden for that annotation legend entry.}

\item{hm_nrow}{\code{integer} number of rows used to display
the heatmap panels. This mechanism is somewhat experimental,
and is used to split a large number of coverage heatmaps into
two rows of heatmaps.
\itemize{
\item The matrix data row order is consistent across all heatmap panels.
\item The annotation data is displayed to the left of each row of
heatmap panels.
}}

\item{transform}{one of the following:
\itemize{
\item \code{character} string referring to a numeric transformation,
passed to \code{get_numeric_transform()}. Commonly used strings:
\itemize{
\item \code{"log2signed"} calls \code{jamba::log2signed()}, which applies
\code{log2(1+x)} to the absolute value, multiplied by \code{sign(x)}
\item \code{"sqrt"} applies square root to the absolute value, multiplied
by the \code{sign(x)}
\item \code{"cubert"} applies cube root \code{x^(1/3)}
\item \code{"qrt"} applies fourth root \code{x^(1/4)} to the absolute value,
multiplied by the \code{sign(x)}
}
\item \code{function} that applies a numeric transformation.
Valid \code{character} string values:
\code{"log2signed"} applies \code{jamba::log2signed()} which applies
\code{log2(1+x)} transform to the absolute value, then multiplies
by the original \code{sign(x)}; \code{"sqrt"} applies square root;
\code{"cubert"} applies cube root \code{x^(1/3)}; \code{"qrt"} applies
fourth root \code{x^(1/4)}. When there are negative numeric
values, the transformation is applied to absolute value,
then multiplied by the original sign. Therefore, the
transformation is applied to adjust the magnitude of
the values. These values are passed to \code{get_numeric_transform()}
which may have more information.
}}

\item{transform_label}{\code{character} optional vector of transformation labels
to use. When \code{transform_label=NULL} (default) it uses \code{names(transform)}
if present, then the \code{character} string of \code{transform}, otherwise
is left blank. When \code{transform="none"} no label is displayed.
By default, transform labels are surrounded by parentheses, for example
\code{"(log2signed)"} and placed on a new line below each coverage heatmap
title. To suppress the transformation in the title, supply
\code{transform_label=""}.}

\item{signal_ceiling}{\code{numeric} vector whose values are recycled
to length \code{length(nmatlist)}. The \code{signal_ceiling}
defines the maximum numeric value to the color ramp for
each matrix in \code{nmatlist}. The value is passed to \code{get_nmat_ceiling()},
which recognizes three numeric forms:
\enumerate{
\item \code{signal_ceiling=NULL}: (default) the maximum absolute value
is used as the ceiling.
\item \code{signal_ceiling > 1}: the specific numeric value
is applied as a fixed ceiling, even if the value is above or below
the maximum absolute value in the data matrix. This setting is useful
for defining a fixed meaningful threshold across \code{nmatlist} entries.
\item \code{signal_ceiling > 0} and \code{signal_ceiling <= 1}: the numeric value
defines a quantile threshold calculated using signal in the data matrix,
excluding values of zero. For example \code{signal_ceiling=0.75} calculates
ceiling \code{quantile(x, probs=0.75)}, using non-zero values.
}

Note that the ceiling is only applied to the color scale and
not to the underlying data. The row clustering and row ordering
steps use the full data range, after applying the appropriate
\code{transform} where applicable.

To apply a numeric ceiling to the data itself, it should be done
at the level of \code{nmatlist} beforehand.}

\item{axis_name}{\code{character} string with optional custom label used for
the target region label in each heatmap panel.
\itemize{
\item When \code{axis_name=NULL} (default), the \code{attr(nmat, "target_name")}
label will be used, which is usually "target", along with the
upstream and downstream length as stored in \code{attr(nmat, "extend")}.
\item a \code{character} vector will be applied as the center
(target) label on each heatmap, using the upstream and downstream
length as stored in \code{attr(nmat, "extend")}.
\item a \code{list} is expected to have three labels per vector element,
corresponding to the upstream, target, and downstream axis label.
This \code{list} is recycled to \code{length(nmatlist)}.
}}

\item{axis_name_gp}{object of \code{grid::gpar} applied to the x-axis label
graphic parameters. For example, to customize the x-axis font size,
use the form: \code{grid::gpar(fontsize=8)}.}

\item{axis_name_rot}{\code{numeric} value either \code{0} or \code{90} indicating
whether to rotate the x-axis names below each heatmap, where
\code{axis_name_row=90} (default) will rotate labels vertically,
and \code{axis_name_row=0} will display labels horizontally.
\itemize{
\item Note that \code{axis_name_rot} also controls the rotation of
annotation (\code{anno_df}) and partition (\code{partition} or \code{k_clusters})
annotation labels, below each annotation heatmap.
}}

\item{column_title_gp}{object \code{grid::gpar} or \code{list} of \code{grid::gpar}
objects, applied across entries in \code{nmatlist} to customize the title
displayed above each heatmap panel.
For example to alter the font size, use \code{grid::gpar(fontsize=14)}.
This argument is passed to \code{ComplexHeatmap::Heatmap()}, and can
be customized for each heatmap as needed.}

\item{lens}{\code{numeric} adjustment to the intensity of the color gradient,
used only when the corresponding \code{nmat_colors} entry uses a fixed
set of colors. \code{lens} above zero create more rapid color changes,
making the gradient more visually intense, values below zero reduce
the intensity.
The \code{lens} values are recycled to \code{length(nmatlist)} as needed.
Note that \code{signal_ceiling} defines the \code{numeric} value at which
the maximum color is applied, while \code{lens} adjusts the intensity of
the intermediate values in the color gradient.}

\item{anno_lens}{\code{numeric} value used to scale the annotation
heatmap color scales, see \code{lens} for details. This value is applied
to \code{numeric} columns only when \code{anno_df} is provided.}

\item{seed}{\code{numeric} value used with \code{set.seed()} to
set the random seed. Set to \code{NULL} to avoid running
\code{set.seed()}.}

\item{ht_gap}{\code{unit} size to specify the gap between multiple heatmaps.
This argument is passed to \code{ComplexHeatmap::draw()}. An example
is \code{grid::unit(8, "mm")} to specify 8 millimeters.}

\item{row_anno_padding, column_anno_padding, legend_padding}{\code{grid::unit}
to define the padding between heatmap body, and row annotation,
column annotation, and heatmap color legend, respectively.
\itemize{
\item The default values are intended to provide more space between heatmap
and these features than between heatmap subsections (\code{row_gap}).
The defaults are 4mm for row and column annotations, and 1cm
for the color legend.
\item The \code{legend_padding} is useful to minimize overlap with
legend and the y-axis labels from the metaplots at the top
of each heatmap.
}}

\item{profile_value}{\code{character} string to define the type of numeric
profile to display at the top of each heatmap. This argument is
passed to \code{EnrichedHeatmap::anno_enriched()}. Values: \code{"mean"} the
mean profile; \code{"sum"} the sum; \code{"abs_sum"} sum of absolute values;
\code{"abs_mean"} the mean of absolute values.}

\item{profile_linetype}{\code{numeric} or \code{character} default c(1, 5, 3)
passed to \code{grid::gpar(lty)}
to define the metaplot line type. Default lty=1 is a solid line.
Values are recycled to the number of profile plots.}

\item{profile_linewidth}{\code{numeric} line width passed to \code{grid::gpar(lwd)}
to control the line width. Default uses lwd=1.5.
Values are recycled to the number of profile plots.}

\item{ylims}{\code{numeric} vector of maximum y-axis values for each heatmap
profile; or \code{list} of min,max values to apply to each \code{nmatlist} entry.}

\item{border}{\code{logical} indicating whether to draw a border around the
heatmap, which includes all heatmap panels in the event of
splitting by clustering. The \code{border} can be supplied as a vector,
so the \code{border} can be applied specifically to each heatmap
if needed.}

\item{iter.max}{\code{integer} value indicating the maximum iterations
performed by k-means clustering, only relevant when \code{k_clusters}
is non-zero.}

\item{use_raster}{\code{logical} indicating whether to create heatmaps
using raster resizing, almost always recommended \code{TRUE}
otherwise the output will be very sub-optimal.}

\item{raster_quality}{\code{logical} passed to \code{ComplexHeatmap::Heatmap()},
used when \code{use_raster=TRUE} and defines the level of detail retained,
and is used only when \code{raster_by_magick=FALSE}. Using larger numbers
decreases speed substantially.}

\item{raster_by_magick}{\code{logical} passed to \code{ComplexHeatmap::Heatmap()},
to enable ImageMagick use during rasterization. By default this
option is \code{TRUE} and is only disabled when the R package
\code{"magick"} is not installed, or not properly configured.
If you see a warning "instalilng 'magick' will improve rasterization"
then check the R package with \code{library(magick)} and see if
there are error messages. When \code{"magick"} is not available,
the rasterization is substantially slower, and may produce
files much larger than normal.}

\item{do_plot}{\code{logical} indicating whether to draw the heatmaps,
\code{do_plot=TRUE} (default) renders the plots as normal.
\code{do_plot=FALSE} will return the data used to create heatmaps
without drawing the heatmaps.}

\item{do_caption}{\code{logical} indicating whether to include a small caption
at the bottom-right of the plot, describing the number of rows and
columns, the partition, k-means clustering, and main heatmap.}

\item{legend_fontsize}{\code{numeric} fontsize to use for all legend text,
default 10.
\itemize{
\item Optionally two values can be defined, the first is used for
legend title, the second is used for legend labels.
}}

\item{padding}{\code{grid::unit} object used during \code{ComplexHeatmap::draw()}
to add whitespace padding around the boundaries of the overall list
of heatmaps. This padding is useful to enforce extra whitespace,
or to prevent labels from exceeding the width of the figure.}

\item{return_type}{\code{character} string indicating the type of
data to return:
\itemize{
\item \code{"heatmaplist"} returns the list of heatmaps,
which can separately be arranged together using
\code{ComplexHeatmap::draw()} or \code{grid::grid.draw()}.
\item \code{"grid"} returns the \code{grid} graphical object which may be easier
to render using something like the \code{patchwork} or \code{cowplot} R packages.
}}

\item{show_error}{\code{logical} indicating whether to add error
bars to the profile plot at the top of each heatmap.
These error bars are calculated by
\code{EnrichedHeatmap::anno_enriched()} using
\code{matrixStats::colSds(x)/nrow(x)}.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{...}{additional arguments are passed to
\code{EnrichedHeatmap::EnrichedHeatmap()} to allow greater
customization of details. Note that many \code{...} arguments
are also passed to \code{ComplexHeatmap::Heatmap()}.}
}
\value{
\code{list} with heatmap components that can be reviewed, or
optionally rendered into a figure:
\itemize{
\item \code{"AHM"}: annotation heatmap, when \code{anno_df} is supplied
\item \code{"PHM"}: partition heatmap, when partitioning and/or k-means clustering
is used
\item \code{"EH_l"}: \code{list} of \code{ComplexHeatmap::Heatmap} objects
\item \code{"MHM"}: marked heatmap, containing optional row labels
\item \code{"HM_drawn"}: when \code{hm_nrow=1} this is the output after drawing the
heatmap, in the form: \code{ComplexHeatmap::HeatmapList}. This object can
be drawn again if needed, or used to determine exact row orders.
\item \code{"fn_params"}: \code{list} of useful function parameters, including
some calculated during processing such as \code{panel_groups}, \code{ylims},
\code{signal_ceiling}, etc.
\item \code{"hm_caption"}: \code{character} version of heatmap captions
\item \code{"adjust_df"}: \code{data.frame} when \code{recenter_heatmap} or
\code{restrand_heatmap} are defined, which contains a summary of each
row, with colnames:
\code{"summit_name"} for recentering; and
\code{"restrand"} for restranding.
}
}
\description{
Make multiple coverage heatmaps
}
\details{
This function takes a list of \code{normalizedMatrix} objects,
usually the output of \code{coverage_matrix2nmat()}, and
produces multiple heatmaps using
\code{EnrichedHeatmap}.

This function is intended to be a convenient wrapper to
help keep each data matrix in order, to apply consistent
clustering and filtering across all data matrices,
and to enable optional multi-row heatmap layout.
}
\section{Annotation Data}{
When \code{anno_df} is provided as a \code{data.frame} the rows are synchronized
alongside the heatmap rows. Column values are color-coded, categorical
for \code{character} columns, and using color gradient for \code{numeric} columns.

Rows can optionally be split by argument \code{partition}, which can be a vector
of group values associated with rows, or one or more columns in
\code{colnames(anno_df)} whose values are used to sub-divide the rows.
}

\section{Row Clustering / Partitioning}{
Rows can be clustered using k-means clustering with argument \code{k_clusters}.
By default it uses \code{k_method="correlation"}, which applies a novel
and effective correlation metric, clustering row data by the profile shape.
The typical default, which is used when the \code{amap} R package is not
installed, is to use \code{"euclidean"} distance, which tends to cluster
based upon signal magnitude moreso than the shape.

When k-means clustering \code{k_clusters} and \code{partition} are both enabled,
each partition is independently k-means clustered, which improves
results compared to applying global k-means before applying partitions.
Use \code{min_rows_per_k} to adjust the relative number of \code{k} clusters
based upon the number of observed rows.
}

\section{Display Layout}{
Heatmaps are arranged in the following order, dependent upon
the data provided:
\itemize{
\item Annotation heatmap, if \code{anno_df} is provided.
\itemize{
\item Color assignment can be provided using \code{color_sub} either as
a named vector of R colors whose names match values in each column,
or as a \code{list} named by \code{colnames(anno_df)}, with named color
assignments, or a color \code{function} for \code{numeric} columns.
}
\item Partition heatmap, if \code{partition} is provided.
\item Enrichment heatmaps, one for each entry in \code{nmatlist}.
\itemize{
\item Above each heatmap is the metaplot, drawn using
\code{EnrichedHeatmap::anno_enriched()}.
\item When \code{partition} and/or \code{k_clusters} are defined,
the plot will include one profile line for each row grouping.
\item When \code{show_error=TRUE} each line will also be shaded using 95\%
standard deviation.
\item The heatmap color gradient is applied starting at zero, extending to
\code{signal_ceiling} for each heatmap. When \code{signal_ceiling} is <=1 it
uses the quantile of non-zero values in the matrix data, otherwise
it applies a fixed numeric maximum. Numeric values above the
\code{signal_ceiling} threshold are colored using the maximum color.
\item When there are negative values, the color key uses a divergent
color scale. When \code{nmat_colors} value for the heatmap is a single color,
the complementary color is used for negative values; otherwise it is
assumed to define a divergent color scale.
\item The y-axis range on metaplots is defined by observed values, and
when \code{panel_groups} is defined, the y-axis \code{ylim} is shared among
all heatmaps in each panel group.
}
\item Marked row heatmap, if \code{anno_row_marks} is provided. It uses an empty
heatmap, associated with row mark annotations for a subset of row labels,
in the same order as the coverage heatmaps.
\item Color legends are displayed in the same order:
\itemize{
\item annotation colors for each column in \code{anno_df}
\item partition/cluster colors
\item color gradients for each coverage heatmap in order, or
when \code{panel_groups} is provided it displays the color key for
only the first heatmap in each panel group.
}
}
}

\examples{
## There is a small example file to use for testing
# library(jamba)
cov_file1 <- system.file("data", "tss_coverage.matrix", package="platjam");
cov_file2 <- system.file("data", "h3k4me1_coverage.matrix", package="platjam");
cov_files <- c(cov_file1, cov_file2);
names(cov_files) <- gsub("[.]matrix",
   "",
   basename(cov_files));
nmatlist <- coverage_matrix2nmat(cov_files, verbose=FALSE);
sapply(nmatlist, function(nmat){attr(nmat, "signal_name")})
nmatlist2heatmaps(nmatlist);

# sometimes data transform can be helpful
nmatlist2heatmaps(nmatlist,
   transform=c("log2signed", "sqrt"));

# k-means clusters, default uses euclidean distance
nmatlist2heatmaps(nmatlist, k_clusters=4,
   transform=c("log2signed", "sqrt"));

# k-means clusters, "correlation" or "pearson" sometimes works better
nmatlist2heatmaps(nmatlist,
   k_clusters=4,
   min_rows_per_k=20,
   k_method="pearson",
   transform=c("log2signed", "sqrt"));

# example showing usage of top_axis_side
# and panel_groups
nmatlist2 <- nmatlist[c(1, 1, 1, 2, 2, 2)];
names(nmatlist2) <- jamba::makeNames(names(nmatlist2))
for (iname in names(nmatlist2)) {
   attr(nmatlist2[[iname]], "signal_name") <- gsub("coverage", "cov", iname);
}
# top_axis_side="left"
# assumes 12x7 figure size
nmatlist2heatmaps(nmatlist2,
   signal_ceiling=0.8,
   nmat_colors=rep(c("firebrick", "tomato"), each=3),
   panel_groups=rep(c("tss", "h3k4me1"), each=3),
   ht_gap=grid::unit(4, "mm"),
   top_axis_side="left",
   transform=rep(c("log2signed", "sqrt"), each=3));

# top_axis_side="both"
nmatlist2heatmaps(nmatlist2,
   panel_groups=rep(c("tss", "h3k4me1"), each=3),
   ht_gap=grid::unit(6, "mm"),
   top_axis_side="both",
   transform=rep(c("log2signed", "sqrt"), each=3));

# multiple heatmap rows
nmatlist2heatmaps(nmatlist2,
   k_clusters=4,
   k_method="pearson",
   hm_nrow=2,
   panel_groups=rep(c("tss", "h3k4me1"), each=3),
   ht_gap=grid::unit(6, "mm"),
   top_axis_side="both",
   top_anno_height=grid::unit(0.8, "cm"),
   transform=rep(c("log2signed", "sqrt"), each=3));

# invent anno_df data.frame of additional annotations
anno_df <- data.frame(
   tss_score=EnrichedHeatmap::enriched_score(jamba::log2signed(nmatlist[[1]])),
   h3k4me1_score=EnrichedHeatmap::enriched_score(jamba::log2signed(nmatlist[[2]])),
   chromosome=paste0("chr", sample(1:4, replace=TRUE, size=nrow(nmatlist[[1]])))
);
rownames(anno_df) <- rownames(nmatlist[[1]]);
nmatlist2heatmaps(nmatlist,
   title="k-means clustering across both heatmaps",
   k_clusters=4,
   k_method="pearson",
   k_heatmap=c(1, 2),
   ht_gap=grid::unit(6, "mm"),
   top_axis_side="left",
   anno_df=anno_df,
   transform=rep(c("log2signed", "sqrt"), each=3));

# example showing k-means clustering together with annotation groups
anno_df <- data.frame(
   group=sample(c(1, -1, -1),
      size=nrow(nmatlist[[1]]),
      replace=TRUE),
   row.names=rownames(nmatlist[[1]]))
# note for this example the color legends are oriented vertically
# showing how the width is adjusted
nmatlist2heatmaps(nmatlist,
   heatmap_legend_direction="vertical",
   k_clusters=0,
   color_sub=c(`A`="firebrick", `B`="darkorchid"),
   k_colors=c("firebrick", "dodgerblue"),
   min_rows_per_k=50,
   ht_gap=grid::unit(1, "cm"),
   k_method="correlation",
   k_heatmap=1:2,
   anno_df=anno_df,
   partition="group",
   row_title_rot=0,
   transform=rep(c("log2signed", "sqrt"), each=3));

# same as above, partition and k_clusters together
# except uses multiple values for k_clusters
nmatlist2heatmaps(nmatlist,
   k_clusters=c(1, 4),
   min_rows_per_k=25,
   k_heatmap=1:2,
   k_method="correlation",
   anno_df=anno_df,
   partition="group",
   row_title_rot=0)

}
\seealso{
Other jam coverage heatmap functions: 
\code{\link{coverage_matrix2nmat}()},
\code{\link{get_nmat_ceiling}()},
\code{\link{nmathm_row_order}()},
\code{\link{recenter_nmatlist}()},
\code{\link{restrand_nmatlist}()},
\code{\link{validate_heatmap_params}()},
\code{\link{zoom_nmat}()},
\code{\link{zoom_nmatlist}()}
}
\concept{jam coverage heatmap functions}
