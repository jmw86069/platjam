% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/platjam-merge-proteomics-se.R
\name{merge_proteomics_se}
\alias{merge_proteomics_se}
\title{merge proteomics SE objects}
\usage{
merge_proteomics_se(
  SE1,
  SE2,
  rowname1 = "SYMBOL",
  rowname2 = "SYMBOL",
  rowData_colnames_intersect = TRUE,
  colData_colnames_intersect = TRUE,
  rowData_colnames_unique = c("percentCoverage", "numPepsUnique", "scoreUnique"),
  assay_names = NULL,
  se_names = c("A", "B"),
  startN = 2,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{SE1, SE2}{\code{SummarizedExperiment} objects to be merged into
one output object.}

\item{rowname1, rowname2}{\code{character} string that describes which
\code{SummarizedExperiment::rowData()} annotation to use to create
appropriate rownames to be merged. This approach is useful when
merging data based upon gene symbol, instead of a protein accession
or peptide sequence. The intent is to allow "equivalent" rows
to be combined across \code{SE1} and \code{SE2}, while non-equivalent rows
unique to \code{SE1} or \code{SE2} are represented on their own row.

The default values assume each proteomics
SE object contains a rowData column \code{"SYMBOL"} with the official
gene symbol represented on each row. This column is appropriate if
proteomics data already represents abundance measurements which
were already aggregated to the protein-level (i.e. gene locus level).
The data will therefore be merged based upon the gene symbol.
In the event that multiple rows represent the same gene symbol,
they will be renamed using \code{jamba::makeNames(..., renameFirst=FALSE)}
so that the entries will be merged in order they appear in each
dataset.

However, if the input data contains peptide-level measurements,
the appropriate column should contain the peptide sequence, so that
the data is merged based upon equivalent peptide sequences.

If \code{rowname1} or \code{rowname2} contain multiple values, and/or are
not equal to each other, a new column \code{"merge_key"} is created
in both \code{SE1} and \code{SE2}, and populated with relevant values.
When multiple columns are indicated, they are concatenated
using \code{jamba::pasteByRow()} to fill the column \code{"merge_key"}.
Then both \code{rowname1} and \code{rowname2} are redefined to
\code{"merge_key"}. Note that any pre-existing \code{"merge_key"} column
will be overwritten.

A combination of \code{"rownames"} and \code{colnames(rowData())} can
be used.

The argument value should contain one value from either:
\enumerate{
\item \code{colnames(rowData())} for the relevant object \code{SE1} or \code{SE2},
representing a row annotation to use as the merge key. Note that
any empty values (\code{NA} or blank string \code{""}) will be replaced
by existing \code{rownames()}.
\item \code{"rownames"} to indicate that existing \code{rownames()} of the
relevant object \code{SE1} or \code{SE2} should be used as the merge key.
Note that if a column \code{"rownames"} already exists in \code{rowData()}
it will be used as-is.
}}

\item{rowData_colnames_intersect, colData_colnames_intersect}{\code{logical}
indicating whether to retain only the intersection of
\code{colnames(rowData())} and \code{colnames(colData())} in the output
rowData and colData, respectively.
\itemize{
\item \code{TRUE}: only the intersection is retained in the output data, default.
\item \code{FALSE}: not yet implemented.
}}

\item{rowData_colnames_unique}{\code{character} vector with optional
\code{colnames(rowData())} which should be retained in a uniquely-named
output column, to keep its values distinct between \code{SE1} and \code{SE2}.
This argument is useful for something like \code{"score"} where independent
datasets are expected to have unique values, and which may be
important to compare.
Note that columns not already being retained will be ignored.}

\item{assay_names}{\code{character} vector with one or more specific assay
names to retain in the output data. By default, all assay names
are retained.}

\item{se_names}{\code{character} vector length=2 to define the output labels
used to indicate which rows and columns were present in \code{SE1} and \code{SE2}.}

\item{startN}{\code{integer} number passed to \code{jamba::makeNames()} to define
the suffix number for the first versioned output. Note that
\code{renameFirst=FALSE} so the first occurrence of a \code{character} string
will not be renamed. When \code{startN=2}, subsequent repeated
entries will have suffix \code{"_v2"}, then \code{"_v3"} and so on.}

\item{...}{additional arguments are passed to \code{jamba::makeNames()}.}
}
\description{
merge proteomics SE objects
}
\details{
See notes for specific arguments for a description of how
data is merged relative to
rows and \code{rowData()}, columns and \code{colData()}.

The general strategy is to merge equivalent rows to integrate rows
across \code{SE1} and \code{SE2}, but to force columns (sample measurements)
to be unique across \code{SE1} and \code{SE2}.

This process is somewhat similar to calling \code{cbind()}, in that
the sample columns are extended. However, the rows are merged where
possible.

No assay measurement values are lost during this process.
}
\seealso{
Other jam utility functions: 
\code{\link{color_complement}()},
\code{\link{curate_se_colData}()},
\code{\link{curate_to_df_by_pattern}()},
\code{\link{get_numeric_transform}()},
\code{\link{rowNormScale}()}
}
\concept{jam utility functions}
