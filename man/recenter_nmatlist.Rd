% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coverjam-recenter-nmatlist.R
\name{recenter_nmatlist}
\alias{recenter_nmatlist}
\title{Re-center coverage matrix data}
\usage{
recenter_nmatlist(
  nmatlist,
  recenter_heatmap = 1,
  recenter_range = NULL,
  recenter_invert = FALSE,
  spar = 0.5,
  edge_buffer = 0,
  empty_value = 0,
  summit_names = NULL,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{nmatlist}{\code{list} of \code{normalizedMatrix} objects}

\item{recenter_heatmap}{\code{numeric} (default 1) index with one or
more entries in \code{nmatlist} to use for re-centering.}

\item{recenter_range}{\code{numeric} (default NULL) with optional
maximum distance from the target (center) of coverage
in \code{nmatlist}. For example, if \code{nmatlist} data spans -50kb to +50kb,
but peaks are no wider than 1kb,  consider using
\code{recenter_range=1000} so that the recentering will only use
coverage data -1000bp to +1000bp at most.}

\item{recenter_invert}{\code{logical} indicating whether to invert the
coverage, therefore effectively taking the minimum signal.
This value is recycled to \code{length(recenter_heatmap)} such that
each heatmap can individually be inverted as relevant.}

\item{empty_value}{\code{numeric} value used for empty values created
by the "edges" of recentered matrix data. Default is 0, other
values may not be well-supported.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{...}{additional arguments are ignored.}

\item{spar.edge.buffer}{\code{numeric} values passed to \code{summit_from_vector()}}
}
\value{
object in format \code{nmatlist}, a \code{list} of \code{normalizedMatrix}
objects.
}
\description{
Re-center coverage matrix data
}
\details{
Coverage matrix data is provided as \code{nmatlist} which is a
\code{list} of \code{normalizedMatrix} objects (see \code{EnrichmentHeatmap}).
One or more \code{recenter_heatmap} are defined, and the summit
is calculated for each row using \code{smooth.spline()}.

For each row, the summit position is therefore interpolated.

Coverage matrix data \code{nmatlist} is then shifted to recenter peaks
across all coverage files, and the summit offset is stored as
an attribute \code{attr(nmatlist, "summit_offset")}.
\subsection{Use Case}{

The input represents sequence coverage data for a set of
genome regions of interest, for example ChIP-seq peaks, ATAC-seq peaks,
where it may be useful for the center of enrichment to
represent the position with highest coverage.
Many peak/regional enrichment calling tools may not provide
a summit position, the summit position may not be accurate,
and/or the summit across multiple sets of merged peaks may
not be available.

This method can use coverage data across multiple \code{nmatlist}
matrix data to calculate a collective summit position.
}

\subsection{Recommendation}{

The recommended workflow is to create coverage matrix data
for a region wider than used for the final figure, so that
the re-centering can be performed while maintaining coverage
throughout the desired range.
}
}
\examples{
## There is a small example file to use for testing
# library(jamba)
cov_file1 <- system.file("data", "tss_coverage.matrix", package="platjam");
cov_file2 <- system.file("data", "h3k4me1_coverage.matrix", package="platjam");
cov_files <- c(cov_file1, cov_file2);
names(cov_files) <- gsub("[.]matrix",
   "",
   basename(cov_files));
nmatlist <- coverage_matrix2nmat(cov_files, verbose=FALSE);

nmatlist2heatmaps(nmatlist,
   title="Input data",
   transform=c("log2signed", "sqrt"));

# recenter on the fly within nmatlist2heatmaps()
nhm <- nmatlist2heatmaps(nmatlist,
   recenter_heatmap=2, recenter_invert=TRUE, recenter_range=c(-300, 300),
   #use_raster=FALSE,
   title="Input data, recentered by tss signal",
   transform=c("log2signed", "sqrt"));

# re-use summit_names to avoid re-calculating
summit_names <- jamba::nameVector(nhm$adjust_df[, c("summit_name", "row")])
nhm2 <- nmatlist2heatmaps(nmatlist,
   summit_names=summit_names,
   title="Input data, recentered by tss signal",
   transform=c("log2signed", "sqrt"));

# re-center upfront and use the results
nmatlist1 <- recenter_nmatlist(nmatlist,
   recenter_heatmap=2, recenter_range=c(-300, 300), recenter_invert=TRUE)
nmatlist2heatmaps(nmatlist1,
   title="Input data, recentered by tss signal",
   transform=c("log2signed", "sqrt"));


nmatlist2is <- restrand_nmatlist(nmatlist2i, restrand_heatmap=2, recenter_invert=FALSE)
nmatlist2heatmaps(nmatlist2is,
   title="Input data, recentered by inverted h3k4me1 signal,\nrestranded by tss",
   transform=c("log2signed", "sqrt"));

# summarize recenter and restrand output
head(data.frame(
   row=attr(nmatlist2is[[1]], "dimnames")[[1]],
   summit_name=attr(nmatlist2is[[1]], "summit_name"),
   restrand=attr(nmatlist2is[[1]], "restrand")))

nhm <- nmatlist2heatmaps(nmatlist,
   title="Input data",
   recenter_heatmap=2,
   transform=c("log2signed", "sqrt"));
jamba::sdim(nhm)

nhm2 <- nmatlist2heatmaps(nmatlist,
   title="Input data",
   summit_names=jamba::nameVector(nhm$adjust_df[, c("summit_name", "row")]),
   transform=c("log2signed", "sqrt"));
nhm2 <- nmatlist2heatmaps(nmatlist,
   title="Input data",
   summit_names=nhm$adjust_df$summit_name,
   transform=c("log2signed", "sqrt"));

}
\seealso{
Other jam coverage heatmap functions: 
\code{\link{coverage_matrix2nmat}()},
\code{\link{get_nmat_ceiling}()},
\code{\link{nmathm_row_order}()},
\code{\link{nmatlist2heatmaps}()},
\code{\link{restrand_nmatlist}()},
\code{\link{validate_heatmap_params}()},
\code{\link{zoom_nmat}()},
\code{\link{zoom_nmatlist}()}
}
\concept{jam coverage heatmap functions}
