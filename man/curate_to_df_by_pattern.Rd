% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jam-curate-to-df.R
\name{curate_to_df_by_pattern}
\alias{curate_to_df_by_pattern}
\title{Curate vector to data.frame by pattern matching}
\usage{
curate_to_df_by_pattern(
  x,
  df,
  pattern_colname = "pattern",
  group_colname = "group",
  id_colname = c("label", "sample"),
  input_colname = "filename",
  suffix = "_rep",
  renameOnes = TRUE,
  colname_hook = jamba::ucfirst,
  sep = "_",
  order_priority = c("df", "x"),
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x}{\code{character} vector of input data, often filenames used
when importing data using one of the \verb{import_*} functions.}

\item{df}{\code{data.frame} whose first column contains \code{character} patterns,
and subsequent columns contain annotations to be applied to entries
in \code{x} that match a given pattern. The column that contains patterns
can be specified with argument \code{pattern_colname}.}

\item{pattern_colname, group_colname, id_colname}{\code{character} string
indicating colname to use for patterns, group, and identifier,
respectively. The \code{group_colname} and \code{id_colname} may be \code{NULL}
in which case they are not used. When \code{group_colname} and
\code{id_colname} are defined, then values in \code{group_colname}
are used to make unique identifiers for each entry in \code{x},
and are stored in \code{id_colname}.}

\item{input_colname}{\code{character} string indicating the colname to
use for the input data supplied by \code{x}. For example when
\code{input_colname="filename"} then values in \code{x} are stored in
a column \code{"filename"}.}

\item{suffix, renameOnes}{arguments passed to \code{jamba::makeNames()},
used when \code{group_colname} and \code{id_colname} are defined,
\code{jamba::makeNames(df[[group_colname]], suffix, renameOnes)}
is used to make unique names for each row.}

\item{colname_hook}{\code{function} called on colnames, for example
\code{jamba::ucfirst()} applies upper-case to the first character
in each colname. When \code{colname_hook=NULL} then no changes
are made.}

\item{sep}{\code{character} string passed to \code{jamba::pasteByRow()} when
concatenating columns to create a unique identifier for each row.}

\item{order_priority}{\code{character} string indicating how the output
\code{data.frame} row order should be defined. Note that the output
will only include entries in \code{x} that were found in the
curation \code{df}.
\itemize{
\item \code{"df"}: output follows the order of matching rows in \code{df}
\item \code{"x"}: output follows the order of matching \code{x} values
}}

\item{...}{additional arguments are passed to \code{jamba::makeNames()}.}
}
\value{
\code{data.frame} with number of rows equal to the length of input,
\code{length(x)}. Columns are defined by the input \code{colnames(df)}.

Note that the row order of the output will match the
curation \code{df} input.
The purpose of sorting by curation \code{df} is so this data can define
the order of factors used in downstream statistical contrasts.
The factor order is used to define the control group, as
the first factor is preferentially the control group.
}
\description{
Curate vector to \code{data.frame} by pattern matching
}
\details{
This function takes a \code{character} vector, and converts it into
a \code{data.frame} using pattern matching defined in the corresponding
\code{df} argument \code{data.frame}. The first column of \code{df} contains
\code{character} string patterns. Whenever a pattern matches
the input vector \code{x}, the annotations for the corresponding row in
\code{df} are applied to that entry in \code{x}.
}
\examples{
df <- data.frame(
   pattern=c("NOV14_p2w5_VEH",
      "NOV14_p4w4_VEH",
      "NOV14_UL3_VEH",
      "NS644_UL3VEH",
      "NS50644_UL3VEH",
      "NS644_p2w5VEH"),
   batch=c("NOV14",
      "NOV14",
      "NOV14",
      "NS644",
      "NS50644",
      "NS644"),
   group=c("p2w5_Veh",
      "p4w4_Veh",
      "UL3_Veh",
      "UL3_Veh",
      "UL3_Veh",
      "p2w5_Veh")
);
## review the input table format
print(df);
x <- c("NOV14_p2w5_VEH_25_v2_CoordSort_deduplicated_SingleFrag_38to100.bam",
   "NOV14_p4w4_VEHrep1_25_v2_CoordSort_deduplicated_SingleFrag_38to100.bam",
   "NOV14_UL3_VEH_25_v2_CoordSort_deduplicated_SingleFrag_38to100.bam",
   "NS644_UL3VEH_25_v3_CoordSort_deduplicated_SingleFrag_38to100.bam",
   "NOV14_p2w5_VEH_50_v2_CoordSort_dedup_singleFragment.bam",
   "NOV14_UL3_VEH_50_v2_CoordSort_dedup_singleFragment.bam",
   "NS50644_UL3VEH_25_v3_CoordSort_deduplicated_SingleFrag.bam",
   "NS644_p2w5VEH_12p5_v3_CoordSort_deduplicated_SingleFrag_38to100.bam")

df_new <- curate_to_df_by_pattern(x, df);
## Review the curated output
print(df_new);

# note that output is in order defined by df
match(x, df_new$Filename)

# output can be ordered by x
df_new_by_x <- curate_to_df_by_pattern(x, df, order_priority="x");
match(x, df_new_by_x$Filename)

## Print a colorized image
colorSub <- colorjam::group2colors(unique(unlist(df_new)));
colorSub <- jamba::makeColorDarker(colorSub, darkFactor=-1.6, sFactor=-1.6);
k <- c(1,2,3,4,5,5,5,5);
df_colors <- as.matrix(df_new[,k]);
df_colors[] <- colorSub[df_colors];
opar <- par("mar"=c(3,3,4,3));
jamba::imageByColors(df_colors,
   adjustMargins=FALSE,
   cellnote=df_new[,k],
   flip="y",
   cexCellnote=c(0.4,0.5)[c(1,2,2,2,1,1,1,1)],
   xaxt="n",
   yaxt="n",
   groupBy="row");
axis(3,
   at=c(1,2,3,4,6.5),
   labels=colnames(df_new));
par(opar);

}
\seealso{
Other jam utility functions: 
\code{\link{color_complement}()},
\code{\link{convert_imputed_assays_to_na}()},
\code{\link{curate_se_colData}()},
\code{\link{get_numeric_transform}()},
\code{\link{merge_proteomics_se}()},
\code{\link{rowNormScale}()}
}
\concept{jam utility functions}
