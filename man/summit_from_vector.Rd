% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coverjam-recenter-nmatlist.R
\name{summit_from_vector}
\alias{summit_from_vector}
\title{Determine summit from numeric vector}
\usage{
summit_from_vector(x, spar = 0.5, edge_buffer = 0, return_height = TRUE, ...)
}
\arguments{
\item{x}{\code{numeric} vector from which a summit will be determined.}

\item{spar}{\code{numeric} or \code{NULL} passed to \code{smooth.spline()} to
adjust the smoothing parameter. The default \code{spar=0.5} appears
to provide smoothing at a reasonable and consistent level for
genome coverage data, which tends to have long stretches of
horizontal coverage that tend to be overfitted when
\code{spar=NULL}.}

\item{edge_buffer}{\code{integer} number of values at the leading
and trailing edge of \code{x} to be ignored when determining the
summit. This argument is experimental, and is intended to
prevent the very beginning or end of a region from being
the "summit" when there may be an internal peak that is
preferred. Note that when \code{(edge_buffer*2) > length(x)}
the entire region is ignored, in which case the middle
position is returned.}

\item{...}{additional arguments are passed to \code{smooth.spline()}.}
}
\value{
\code{integer} vector with two values:
\itemize{
\item \code{"summit"} with the index position of the highest point
on the smoothed spline curve.
If \code{x} has one uniform numeric value across the entire range,
it returns the midpoint defined by \code{round(length(x)/2)}.
If are two maximum values, the first position is returned.
\item \code{"summit_height"} \code{numeric} value with the spline height
at the summit position.
}
}
\description{
Determine summit from numeric vector
}
\details{
This function takes a numeric vector, intended to be data that
represents some signal across a range where that signal is above
noise; it calls \code{smooth.spline()} to generate a smooth curve across
the region, then returns the x position with the max smoothed
spline signal.

The original intent is to take genome sequence coverage across
an enriched region (a "peak") and determine the peak summit.
It should work well for each row of a coverage matrix, provided the
coverage matrix is wide enough that the highest signal is located
inside the range analyzed.

The other alternative is to import bigWig coverage data for a set
of regions of interest defined by a \code{GRanges} object.
A useful function is \code{splicejam::getGRcoverageFromBw()} which
can load coverage from one or multiple bigWig files, returning
a \code{GRanges} object with one column per bigWig file loaded.
Then iterate each coverage vector to determine the summit.
}
\seealso{
Other jam utility functions: 
\code{\link{cardinality}()},
\code{\link{color_complement}()},
\code{\link{convert_PD_df_to_SE}()},
\code{\link{convert_imputed_assays_to_na}()},
\code{\link{curate_se_colData}()},
\code{\link{curate_to_df_by_pattern}()},
\code{\link{design2layout}()},
\code{\link{get_numeric_transform}()},
\code{\link{handle_df_args}()},
\code{\link{merge_proteomics_se}()},
\code{\link{nmat_summary}()},
\code{\link{nmatlist_summary}()},
\code{\link{rmd_tab_iterator}()},
\code{\link{rowNormScale}()}
}
\concept{jam utility functions}
